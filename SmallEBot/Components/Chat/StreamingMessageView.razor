@* Streaming assistant message bubble: reasoning blocks, text segments, tool calls, and fallback text. *@
@using SmallEBot.Components.Chat.ViewModels.Streaming
@using SmallEBot.Core.Models
<MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
    <MudChatBubble>
        <MudText Typo="Typo.caption">SmallEBot Â· @Timestamp.ToString("g")</MudText>
        @if (Items != null)
        {
            @foreach (var item in Items)
            {
                if (item is { IsReasoningBlock: true, Steps: { Count: > 0 } steps })
                {
                    var toolCount = steps.Count(x => !x.IsThink);
                    var panelTitle = toolCount > 0 ? $"ðŸ’­ Reasoning ({toolCount} tool calls)" : "ðŸ’­ Reasoning";
                    <MudExpansionPanels Class="mt-2 smallebot-reasoning-panel" Elevation="0">
                        <MudExpansionPanel expanded="false" Text="@panelTitle">
                            <div class="d-flex flex-column gap-3">
                                <ReasoningBlockView Steps="@steps" />
                                @if (ShowWaitingForToolParams && WaitingInReasoning)
                                {
                                    <WaitingForToolParamsView Elapsed="@WaitingElapsed" OnCancel="@OnCancel" WrapperClass="" />
                                }
                            </div>
                        </MudExpansionPanel>
                    </MudExpansionPanels>
                }
                else if (item.IsText)
                {
                    <div class="smallebot-reasoning-step">
                        <MarkdownContentView Content="@item.Text" />
                    </div>
                }
                else if (item.IsReplyTool && ShowToolCalls)
                {
                    <div class="smallebot-reasoning-step">
                        <ToolCallView ToolName="@item.ToolName"
                                      ToolArguments="@item.ToolArguments"
                                      ToolResult="@item.ToolResult"
                                      Phase="@item.Phase"
                                      Elapsed="@item.Elapsed"
                                      ShowToolCalls="@ShowToolCalls"
                                      OnCancel="@(CanShowCancel(item.Phase) ? OnCancel : EventCallback.Empty)" />
                    </div>
                }
            }
            @if (ShowWaitingForToolParams && !WaitingInReasoning)
            {
                <WaitingForToolParamsView Elapsed="@WaitingElapsed" OnCancel="@OnCancel" WrapperClass="mt-3" />
            }
        }
        @if (ShowFallbackText)
        {
            <MarkdownContentView Content="@FallbackText" />
        }
    </MudChatBubble>
</MudChat>

@code {
    [Parameter] public IReadOnlyList<StreamingDisplayItemView>? Items { get; set; }
    [Parameter] public string? FallbackText { get; set; }
    [Parameter] public DateTime Timestamp { get; set; } = DateTime.Now;
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public bool ShowWaitingForToolParams { get; set; }
    [Parameter] public TimeSpan WaitingElapsed { get; set; }
    [Parameter] public bool WaitingInReasoning { get; set; }
    [Parameter] public bool ShowToolCalls { get; set; } = true;

    private bool ShowFallbackText => (Items is null || Items.Count == 0) && !string.IsNullOrEmpty(FallbackText);

    private static bool CanShowCancel(ToolCallPhase phase) =>
        phase is ToolCallPhase.Started or ToolCallPhase.ArgsReceived or ToolCallPhase.Executing;
}
