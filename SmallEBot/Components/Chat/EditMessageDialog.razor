@using SmallEBot.Models
@implements IDisposable
@inject IWorkspaceService WorkspaceService
@inject ISkillsConfigService SkillsConfigService
@inject IJSRuntime JS

<MudDialog>
    <TitleContent>
        <MudText Typo="Typo.h6">Edit message</MudText>
    </TitleContent>
    <DialogContent>
        <div id="edit-message-dialog-input-wrap" class="position-relative">
            <AttachmentPopover @ref="_attachmentPopoverRef"
                              @bind-Open="_popoverOpen"
                              Kind="@_popoverKind"
                              Filter="@_popoverFilter"
                              FilePaths="@_filePaths"
                              Skills="@_skills"
                              OnSelect="@OnAttachmentSelected" />
            <AttachmentChips Attachments="@_attachmentItems"
                             RequestedSkillIds="@_requestedSkillIds"
                             OnRemoveAttachment="@RemoveAttachmentItem"
                             OnRemoveSkill="@RemoveSkill" />
            <MudTextField Value="_content"
                         ValueChanged="@((string v) => HandleInputChanged(v))"
                         Immediate="true"
                         Label="Message"
                         Placeholder="@("Use @ for files, / for skills")"
                         Variant="Variant.Outlined"
                         Lines="4"
                         Style="min-width: 400px" />
        </div>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@Cancel">Cancel</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@Save" Disabled="@string.IsNullOrWhiteSpace(_content)">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] IMudDialogInstance MudDialog { get; set; } = null!;
    [Parameter] public string InitialContent { get; set; } = "";
    [Parameter] public IReadOnlyList<string> InitialAttachedPaths { get; set; } = [];
    [Parameter] public IReadOnlyList<string> InitialRequestedSkillIds { get; set; } = [];

    private string _content = "";
    private List<AttachmentItem> _attachmentItems = [];
    private readonly List<string> _requestedSkillIds = [];
    private bool _popoverOpen;
    private string _popoverKind = "file";
    private string _popoverFilter = "";
    private List<string> _filePaths = [];
    private List<SkillMetadata> _skills = [];
    private bool _justSelectedAttachment;
    private bool _syncInputValueInNextRender;
    private bool _suggestionKeysAttached;
    private DotNetObjectReference<EditMessageDialog>? _suggestionKeysDotNetRef;
    private AttachmentPopover? _attachmentPopoverRef;

    protected override void OnParametersSet()
    {
        _content = InitialContent;
        _attachmentItems = InitialAttachedPaths.Select(p => new ResolvedPathAttachment(p)).ToList<AttachmentItem>();
        _requestedSkillIds.Clear();
        _requestedSkillIds.AddRange(InitialRequestedSkillIds);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_syncInputValueInNextRender)
        {
            _syncInputValueInNextRender = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.setChatInputValueAndCursorToEnd", "edit-message-dialog-input-wrap", _content);
            }
            catch { /* ignore if JS not loaded */ }
        }

        if (_popoverOpen && !_suggestionKeysAttached)
        {
            _suggestionKeysAttached = true;
            _suggestionKeysDotNetRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.attachChatInputSuggestionKeys", "edit-message-dialog-input-wrap", _suggestionKeysDotNetRef);
            }
            catch
            {
                _suggestionKeysAttached = false;
                _suggestionKeysDotNetRef?.Dispose();
                _suggestionKeysDotNetRef = null;
            }
        }
        else if (!_popoverOpen && _suggestionKeysAttached)
        {
            _suggestionKeysAttached = false;
            try { await JS.InvokeVoidAsync("SmallEBot.detachChatInputSuggestionKeys", "edit-message-dialog-input-wrap"); } catch { /* ignore */ }
            _suggestionKeysDotNetRef?.Dispose();
            _suggestionKeysDotNetRef = null;
        }
    }

    [JSInvokable]
    public async Task OnSuggestionKeyDown(string key)
    {
        if (_attachmentPopoverRef != null)
            await _attachmentPopoverRef.HandleKeyFromInputAsync(key);
    }

    private async Task HandleInputChanged(string v)
    {
        if (_justSelectedAttachment)
        {
            _justSelectedAttachment = false;
            return;
        }
        _content = v;
        var lastAt = v.LastIndexOf('@');
        var lastSlash = v.LastIndexOf('/');
        if (lastSlash > lastAt)
        {
            _popoverKind = "skill";
            _popoverOpen = true;
            _popoverFilter = lastSlash + 1 < v.Length ? v[(lastSlash + 1)..] : "";
            if (_skills.Count == 0)
                _skills = (await SkillsConfigService.GetMetadataForAgentAsync()).ToList();
        }
        else if (lastAt >= 0)
        {
            _popoverKind = "file";
            _popoverOpen = true;
            _popoverFilter = lastAt + 1 < v.Length ? v[(lastAt + 1)..] : "";
            if (_filePaths.Count == 0)
                _filePaths = (await WorkspaceService.GetAllowedFilePathsAsync()).ToList();
        }
        else
        {
            _popoverOpen = false;
        }
        StateHasChanged();
    }

    private Task OnAttachmentSelected(string value)
    {
        if (_popoverKind == "file")
        {
            if (!_attachmentItems.OfType<ResolvedPathAttachment>().Any(a => string.Equals(a.Path, value, StringComparison.OrdinalIgnoreCase)))
                _attachmentItems.Add(new ResolvedPathAttachment(value));
            var lastAt = _content.LastIndexOf('@');
            _content = lastAt >= 0 ? _content[..lastAt].TrimEnd() : _content;
        }
        else
        {
            if (!_requestedSkillIds.Any(s => string.Equals(s, value, StringComparison.OrdinalIgnoreCase)))
                _requestedSkillIds.Add(value);
            var lastSlash = _content.LastIndexOf('/');
            _content = lastSlash >= 0 ? _content[..lastSlash].TrimEnd() : _content;
        }
        if (_content.Length > 0 && !_content.EndsWith(' '))
            _content += " ";
        _justSelectedAttachment = true;
        _syncInputValueInNextRender = true;
        _popoverOpen = false;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private void RemoveAttachmentItem(AttachmentItem item)
    {
        _attachmentItems.Remove(item);
        StateHasChanged();
    }

    private void RemoveSkill(string skillId)
    {
        _requestedSkillIds.Remove(skillId);
        StateHasChanged();
    }

    private void Cancel() => MudDialog.Cancel();

    private void Save() => MudDialog.Close(DialogResult.Ok(new EditMessageResult(
        _content.Trim(),
        _attachmentItems.OfType<ResolvedPathAttachment>().Select(x => x.Path).ToList(),
        [.._requestedSkillIds])));

    public void Dispose()
    {
        try { _ = JS.InvokeVoidAsync("SmallEBot.detachChatInputSuggestionKeys", "edit-message-dialog-input-wrap"); } catch { /* ignore */ }
        _suggestionKeysDotNetRef?.Dispose();
        _suggestionKeysDotNetRef = null;
    }
}
