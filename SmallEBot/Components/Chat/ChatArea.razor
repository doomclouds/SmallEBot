@using SmallEBot.Models
@inject AgentService AgentSvc
@inject UserNameService UserNameSvc
@inject MarkdownService MarkdownSvc
@inject IJSRuntime JS
@inject ISnackbar Snackbar

<MudPaper Class="pa-4 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Groups.Any())
    {
        @foreach (var group in Groups)
        {
            @if (group is UserMessageGroup userGroup)
            {
                var msg = userGroup.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">You ¬∑ @msg.CreatedAt.ToString("g")</MudText>
                        @if (!string.IsNullOrEmpty(msg.Content))
                        {
                            <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(msg.Content))</div>
                        }
                    </MudChatBubble>
                </MudChat>
            }
            else if (group is AssistantMessageGroup asstGroup)
            {
                var segments = GetHistoryDisplayFromItems(asstGroup.Items);
                var blocks = GetHistoryDisplayBlocks(segments);
                var firstCreatedAt = asstGroup.Items.Count > 0 ? asstGroup.Items[0].CreatedAt : DateTime.UtcNow;
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">SmallEBot ¬∑ @firstCreatedAt.ToString("g")</MudText>
                        @foreach (var block in blocks)
                        {
                            @if (block.ReasoningSteps is { Count: > 0 } steps)
                            {
                                var toolCount = steps.Count(x => !x.IsThink);
                                var panelTitle = toolCount > 0 ? $"üí≠ Êé®ÁêÜËøáÁ®ã (Âê´ {toolCount} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®)" : "üí≠ Êé®ÁêÜËøáÁ®ã";
                                <MudExpansionPanels Class="mt-2" Elevation="0">
                                    <MudExpansionPanel expanded="false" Text="@panelTitle">
                                        <div class="d-flex flex-column gap-2">
                                            @foreach (var step in steps)
                                            {
                                                if (step.IsThink)
                                                {
                                                    <div class="smallebot-reasoning-step">
                                                        <MudText Typo="Typo.caption" Class="mb-1 smallebot-reasoning-label">ÊÄùËÄÉ</MudText>
                                                        @if (!string.IsNullOrEmpty(step.Text))
                                                        {
                                                            <div class="markdown-body smallebot-reasoning-body">@((MarkupString)MarkdownSvc.ToHtml(step.Text))</div>
                                                        }
                                                    </div>
                                                }
                                                else if (ShowToolCalls)
                                                {
                                                    <div class="smallebot-reasoning-step">
                                                        <MudExpansionPanels Elevation="0" Class="pa-0">
                                                            <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                                                @if (!string.IsNullOrEmpty(step.ToolArguments))
                                                                {
                                                                    <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                                                }
                                                                @if (!string.IsNullOrEmpty(step.ToolResult))
                                                                {
                                                                    <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                                                }
                                                            </MudExpansionPanel>
                                                        </MudExpansionPanels>
                                                    </div>
                                                }
                                            }
                                        </div>
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            }
                            else if (block.ToolSegment != null && ShowToolCalls)
                            {
                                var step = block.ToolSegment;
                                <div class="mt-2">
                                    <MudExpansionPanels Elevation="0" Class="pa-0">
                                        <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                            @if (!string.IsNullOrEmpty(step.ToolArguments))
                                            {
                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                            }
                                            @if (!string.IsNullOrEmpty(step.ToolResult))
                                            {
                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                            }
                                        </MudExpansionPanel>
                                    </MudExpansionPanels>
                                </div>
                            }
                            else if (block.Text != null)
                            {
                                <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(block.Text))</div>
                            }
                        }
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage))
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You ¬∑ @_pendingUserMessageTime.ToString("g")</MudText>
                <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(_pendingUserMessage))</div>
            </MudChatBubble>
        </MudChat>
    }
    @if (_streaming || _showLastStreamedReply)
    {
        <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">SmallEBot ¬∑ @DateTime.Now.ToString("g")</MudText>
                @foreach (var item in GetStreamingDisplayItems())
                {
                    if (item is { IsReasoningGroup: true, ReasoningSteps: { Count: > 0 } steps })
                    {
                        var toolCount = steps.Count(x => !x.IsThink);
                        var panelTitle = toolCount > 0 ? $"üí≠ Êé®ÁêÜËøáÁ®ã (Âê´ {toolCount} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®)" : "üí≠ Êé®ÁêÜËøáÁ®ã";
                        <MudExpansionPanels Class="mt-2" Elevation="0">
                            <MudExpansionPanel expanded="false" Text="@panelTitle">
                                <div class="d-flex flex-column gap-2">
                                    @foreach (var step in steps)
                                    {
                                        if (step.IsThink)
                                        {
                                            <div class="smallebot-reasoning-step">
                                                <MudText Typo="Typo.caption" Class="mb-1 smallebot-reasoning-label">ÊÄùËÄÉ</MudText>
                                                @if (!string.IsNullOrEmpty(step.Text))
                                                {
                                                    <div class="markdown-body smallebot-reasoning-body">@((MarkupString)MarkdownSvc.ToHtml(step.Text))</div>
                                                }
                                            </div>
                                        }
                                        else if (ShowToolCalls)
                                        {
                                            <div class="smallebot-reasoning-step">
                                                <MudExpansionPanels Elevation="0" Class="pa-0">
                                                    <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                                        @if (!string.IsNullOrEmpty(step.ToolArguments))
                                                        {
                                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                                        }
                                                        @if (!string.IsNullOrEmpty(step.ToolResult))
                                                        {
                                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                                        }
                                                    </MudExpansionPanel>
                                                </MudExpansionPanels>
                                            </div>
                                        }
                                    }
                                </div>
                            </MudExpansionPanel>
                        </MudExpansionPanels>
                    }
                    else if (item.IsText)
                    {
                        <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(item.Text))</div>
                    }
                }
                @if (!GetStreamingDisplayItems().Any() && !string.IsNullOrEmpty(_streamingText))
                {
                    <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(_streamingText))</div>
                }
            </MudChatBubble>
        </MudChat>
    }
    </div>

    <MudStack Row="true" Spacing="2" Class="mt-4">
        <MudTextField @bind-Value="_input"
                      Label="Message"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      OnKeyDown="@OnKeyDown" />
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="@Send"
                   Disabled="@(_streaming || string.IsNullOrWhiteSpace(_input))">
            Send
        </MudButton>
    </MudStack>
</MudPaper>

@code {
    [Parameter] public List<MessageGroup> Groups { get; set; } = new();
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; }

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private readonly List<StreamUpdate> _streamingUpdates = [];
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>True after persist: show last streamed reply without refetching (avoids full re-render). Cleared when conversation changes or next send.</summary>
    private bool _showLastStreamedReply;

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        await OnBeforeSend.InvokeAsync();
        _showLastStreamedReply = false;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _scrollToBottomRequested = true;
        StateHasChanged();

        var persisted = false;
        try
        {
            var userName = UserNameSvc.CurrentDisplayName ?? UserName;
            if (string.IsNullOrWhiteSpace(userName))
            {
                Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
                _pendingUserMessage = "";
                _streaming = false;
                await InvokeAsync(StateHasChanged);
                return;
            }
            await foreach (var update in AgentSvc.SendMessageStreamingAsync(ConversationId!.Value, msg, UseThinkingMode))
            {
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                _scrollToBottomRequested = true;
                StateHasChanged();
            }
            var items = GetStreamingDisplayItems().ToList();
            var segments = new List<AssistantSegment>();
            foreach (var x in items)
            {
                if (x is { IsReasoningGroup: true, ReasoningSteps: not null })
                {
                    foreach (var step in x.ReasoningSteps)
                    {
                        segments.Add(step.IsThink ? new AssistantSegment(IsText: false, IsThink: true, Text: step.Text ?? "") : new AssistantSegment(IsText: false, IsThink: false, ToolName: step.ToolName ?? "", Arguments: step.ToolArguments, Result: step.ToolResult));
                    }
                }
                else if (x.IsText)
                {
                    segments.Add(new AssistantSegment(IsText: true, Text: x.Text ?? ""));
                }
            }
            if (segments.Count == 0 && !string.IsNullOrEmpty(_streamingText))
                segments.Add(new AssistantSegment(IsText: true, Text: _streamingText));
            await AgentSvc.PersistMessagesAsync(ConversationId!.Value, userName, msg, segments);
            persisted = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            if (persisted)
            {
                await OnMessageSent.InvokeAsync();
                _pendingUserMessage = "";
                // Parent does full refresh; do not show streaming block to avoid duplicate reply
            }
            _streaming = false;
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            _showLastStreamedReply = false;
            if (Groups.Count > 0)
                _scrollToBottomRequested = true;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollToBottomRequested || _streaming)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e is { Key: "Enter", ShiftKey: false }) await Send();
    }

    /// <summary>Ordered list of segments (think / tool / text) for display. Êé®ÁêÜËøáÁ®ã = think only; tools shown separately in order.</summary>
    private static List<HistoryDisplaySegment> GetHistoryDisplayFromItems(IReadOnlyList<TimelineItem> items)
    {
        var list = new List<HistoryDisplaySegment>();
        foreach (var item in items)
        {
            if (item.Message is { Role: "assistant" } && !string.IsNullOrEmpty(item.Message.Content))
                list.Add(new HistoryDisplaySegment { IsText = true, Text = item.Message.Content });
            else if (item.ThinkBlock != null)
                list.Add(new HistoryDisplaySegment { IsThink = true, Text = item.ThinkBlock.Content });
            else if (item.ToolCall != null)
                list.Add(new HistoryDisplaySegment { IsTool = true, ToolName = item.ToolCall.ToolName, ToolArguments = item.ToolCall.Arguments, ToolResult = item.ToolCall.Result });
        }
        return list;
    }

    private sealed class HistoryDisplaySegment
    {
        public bool IsThink { get; init; }
        public bool IsTool { get; init; }
        public bool IsText { get; init; }
        public string? Text { get; init; }
        public string? ToolName { get; init; }
        public string? ToolArguments { get; init; }
        public string? ToolResult { get; init; }
    }

    /// <summary>Thinking mode: one Êé®ÁêÜËøáÁ®ã block (think-tool-think-tool) then text-tool-text-tool. Non-thinking: no Êé®ÁêÜËøáÁ®ã, only text-tool-text-tool order.</summary>
    private static List<HistoryDisplayBlock> GetHistoryDisplayBlocks(List<HistoryDisplaySegment> segments)
    {
        var hasThink = segments.Any(s => s.IsThink);
        var blocks = new List<HistoryDisplayBlock>();
        if (hasThink)
        {
            // Thinking mode: reasoning block = all think + tool until first text
            var reasoningSteps = new List<ReasoningStep>();
            var i = 0;
            for (; i < segments.Count && !segments[i].IsText; i++)
            {
                var seg = segments[i];
                if (seg.IsThink)
                    reasoningSteps.Add(new ReasoningStep { IsThink = true, Text = seg.Text });
                else if (seg.IsTool)
                    reasoningSteps.Add(new ReasoningStep { IsThink = false, ToolName = seg.ToolName, ToolArguments = seg.ToolArguments, ToolResult = seg.ToolResult });
            }
            if (reasoningSteps.Count > 0)
                blocks.Add(new HistoryDisplayBlock { ReasoningSteps = reasoningSteps });
            for (; i < segments.Count; i++)
            {
                var seg = segments[i];
                if (seg.IsTool)
                    blocks.Add(new HistoryDisplayBlock { ToolSegment = seg });
                else if (seg.IsText && !string.IsNullOrEmpty(seg.Text))
                    blocks.Add(new HistoryDisplayBlock { Text = seg.Text });
            }
        }
        else
        {
            // Non-thinking mode: no Êé®ÁêÜËøáÁ®ã, only text-tool-text-tool in order
            foreach (var seg in segments)
            {
                if (seg.IsTool)
                    blocks.Add(new HistoryDisplayBlock { ToolSegment = seg });
                else if (seg.IsText && !string.IsNullOrEmpty(seg.Text))
                    blocks.Add(new HistoryDisplayBlock { Text = seg.Text });
            }
        }
        return blocks;
    }

    private sealed class HistoryDisplayBlock
    {
        /// <summary>Thinking mode only: think-tool-think-tool inside Êé®ÁêÜËøáÁ®ã.</summary>
        public List<ReasoningStep>? ReasoningSteps { get; init; }
        public HistoryDisplaySegment? ToolSegment { get; init; }
        public string? Text { get; init; }
    }

    private sealed class ReasoningStep
    {
        public bool IsThink { get; init; }
        public string? Text { get; set; }
        public string? ToolName { get; init; }
        public string? ToolArguments { get; init; }
        public string? ToolResult { get; set; }
    }

    private sealed class StreamDisplayItem
    {
        public bool IsReasoningGroup { get; init; }
        public List<ReasoningStep>? ReasoningSteps { get; init; }
        public bool IsText { get; init; }
        public string? Text { get; init; }
    }

    private IEnumerable<StreamDisplayItem> GetStreamingDisplayItems()
    {
        var rawList = new List<StreamDisplayItem>();
        var reasoningSteps = new List<ReasoningStep>();
        var toolStepsAfterText = new List<ReasoningStep>();
        var seenText = false;

        foreach (var update in _streamingUpdates)
        {
            if (update is TextStreamUpdate t)
            {
                seenText = true;
                if (rawList.Count > 0 && rawList[^1] is { IsText: true } lastText)
                    rawList[^1] = new StreamDisplayItem { IsText = true, Text = (lastText.Text ?? "") + t.Text };
                else
                    rawList.Add(new StreamDisplayItem { IsText = true, Text = t.Text });
                continue;
            }
            if (update is ThinkStreamUpdate think)
            {
                if (seenText)
                {
                    if (rawList.Count > 0 && rawList[^1] is { IsText: true } lt)
                        rawList[^1] = new StreamDisplayItem { IsText = true, Text = (lt.Text ?? "") + think.Text };
                    else
                        rawList.Add(new StreamDisplayItem { IsText = true, Text = think.Text });
                }
                else
                {
                    if (reasoningSteps.Count > 0 && reasoningSteps[^1].IsThink)
                        reasoningSteps[^1].Text = (reasoningSteps[^1].Text ?? "") + think.Text;
                    else
                        reasoningSteps.Add(new ReasoningStep { IsThink = true, Text = think.Text });
                }
                continue;
            }
            if (update is ToolCallStreamUpdate tc)
            {
                var targetList = seenText ? toolStepsAfterText : reasoningSteps;
                if (tc is { Result: not null, Arguments: null })
                {
                    var lastTool = targetList.LastOrDefault(x => !x.IsThink);
                    lastTool?.ToolResult = tc.Result;
                }
                else if (!string.IsNullOrEmpty(tc.ToolName) || tc.Arguments != null)
                {
                    targetList.Add(new ReasoningStep { IsThink = false, ToolName = tc.ToolName, ToolArguments = tc.Arguments, ToolResult = tc.Result });
                }
            }
        }

        var result = new List<StreamDisplayItem>();
        if (reasoningSteps.Count > 0)
        {
            result.Add(new StreamDisplayItem
            {
                IsReasoningGroup = true,
                ReasoningSteps = reasoningSteps
            });
        }
        result.AddRange(rawList.Where(x => x.IsText));
        if (toolStepsAfterText.Count > 0)
        {
            result.Add(new StreamDisplayItem
            {
                IsReasoningGroup = true,
                ReasoningSteps = toolStepsAfterText
            });
        }
        return result;
    }
}
