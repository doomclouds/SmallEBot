@using System.IO
@using SmallEBot.Application.Conversation
@using SmallEBot.Components.Chat.ViewModels.Bubbles
@using SmallEBot.Components.Chat.ViewModels.Streaming
@using SmallEBot.Components.Chat.Services
@using SmallEBot.Core
@using SmallEBot.Core.Models
@using SmallEBot.Models
@using SmallEBot.Services.Circuit
@inject IAgentConversationService ConversationPipeline
@inject IDialogService DialogSvc
@inject IWorkspaceUploadService UploadService
@inject ICurrentCircuitAccessor CircuitAccessor
@inject AgentCacheService AgentCache
@inject UserNameService UserNameSvc
@inject IWorkspaceService WorkspaceService
@inject ISkillsConfigService SkillsConfigService
@inject IModelConfigService ModelConfigService
@inject ChatPresentationService Presentation
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject ILogger<ChatArea> Log
@implements IDisposable

<MudPaper Class="pa-4 pb-1 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    <MessageList @ref="_messageListRef"
                 Bubbles="@_bubbleViews"
                 PendingUserMessage="@_pendingUserBubble"
                 ShowToolCalls="@ShowToolCalls"
                 OnEditMessage="@HandleEditMessage"
                 OnRegenerateReply="@HandleRegenerateReply" />
    @* Only show streaming block while actively streaming; after persist parent refresh shows reply from Bubbles (avoids duplicate AI bubble). *@
    <StreamingIndicator IsStreaming="@_streaming"
                        StreamingItems="@_streamingViews"
                        FallbackText="@_streamingText"
                        Timestamp="@DateTime.Now"
                        OnCancel="@StopSend"
                        ShowWaitingForToolParams="@_showWaitingForToolParams"
                        WaitingElapsed="@(_showWaitingForToolParams && _waitingForToolParamsSince.HasValue ? DateTime.UtcNow - _waitingForToolParamsSince.Value : TimeSpan.Zero)"
                        WaitingInReasoning="@_waitingInReasoning"
                        ShowToolCalls="@ShowToolCalls"
                        IsCompressing="@_compressing"
                        CompressionMessage="@_compressionMessage" />
    </div>

    <div class="mt-2">
        <ChatInputArea InputText="@_input"
                       InputTextChanged="@HandleInputChanged"
                       IsStreaming="@_streaming"
                       Attachments="@_attachmentItems"
                       RequestedSkillIds="@_requestedSkillIds"
                       PopoverOpen="@_popoverOpen"
                       PopoverKind="@_popoverKind"
                       PopoverFilter="@_popoverFilter"
                       FilePaths="@_filePaths"
                       Skills="@_skills"
                       ContextPercentText="@_contextPercentText"
                       ContextUsageTooltip="@_contextUsageTooltip"
                       OnSend="@Send"
                       OnStop="@StopSend"
                       OnRemoveAttachment="@RemoveAttachmentItem"
                       OnRemoveSkill="@RemoveRequestedSkill"
                       InputTextWithPopover="@OnAttachmentSelected" />
    </div>
</MudPaper>

@code {
    [Parameter] public List<ChatBubble> Bubbles { get; set; } = [];
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; }

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private readonly List<StreamUpdate> _streamingUpdates = [];
    private IReadOnlyList<StreamingDisplayItemView> _streamingViews = [];
    private DateTime? _lastStreamActivityAt;
    private bool _showWaitingForToolParams;
    private DateTime? _waitingForToolParamsSince;
    private bool _waitingInReasoning;
    private Timer? _waitingCheckTimer;
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    private int _bubbleCountBeforeSend;
    private CancellationTokenSource? _sendCts;
    private string _contextPercentText = "—";
    private string? _contextUsageTooltip;
    private bool _popoverOpen;
    private string _popoverKind = "file";
    private string _popoverFilter = "";
    private IReadOnlyList<string> _filePaths = [];
    private IReadOnlyList<SkillMetadata> _skills = [];
    private bool _moveCursorToEnd;
    private readonly List<AttachmentItem> _attachmentItems = [];
    private readonly List<string> _requestedSkillIds = [];
    private DotNetObjectReference<ChatArea>? _dropZoneDotNetRef;
    private bool _justSelectedAttachment;
    private bool _compressing;
    private string _compressionMessage = "";

    private async Task HandleInputChanged(string v)
    {
        if (_justSelectedAttachment)
        {
            _justSelectedAttachment = false;
            return;
        }
        _input = v;
        var lastAt = v.LastIndexOf('@');
        var lastSlash = v.LastIndexOf('/');
        if (lastSlash > lastAt)
        {
            _popoverKind = "skill";
            _popoverOpen = true;
            _popoverFilter = lastSlash + 1 < v.Length ? v[(lastSlash + 1)..] : "";
            if (_skills.Count == 0)
                _skills = await SkillsConfigService.GetMetadataForAgentAsync();
        }
        else if (lastAt >= 0)
        {
            _popoverKind = "file";
            _popoverOpen = true;
            _popoverFilter = lastAt + 1 < v.Length ? v[(lastAt + 1)..] : "";
            if (_filePaths.Count == 0)
                _filePaths = await WorkspaceService.GetAllowedFilePathsAsync();
        }
        else
        {
            ClosePopover();
        }
        StateHasChanged();
    }

    private void ClosePopover()
    {
        _popoverOpen = false;
    }

    private async Task OnAttachmentSelected(string value)
    {
        if (_popoverKind == "file")
        {
            if (_attachmentItems.OfType<ResolvedPathAttachment>().All(x => x.Path != value))
                _attachmentItems.Add(new ResolvedPathAttachment(value));
            var lastAt = _input.LastIndexOf('@');
            _input = lastAt >= 0 ? _input[..lastAt].TrimEnd() : _input;
        }
        else
        {
            if (!_requestedSkillIds.Any(s => string.Equals(s, value, StringComparison.OrdinalIgnoreCase)))
                _requestedSkillIds.Add(value);
            var lastSlash = _input.LastIndexOf('/');
            _input = lastSlash >= 0 ? _input[..lastSlash].TrimEnd() : _input;
        }
        if (_input.Length > 0 && !_input.EndsWith(' '))
            _input += " ";
        _justSelectedAttachment = true;
        ClosePopover();
        _moveCursorToEnd = true;
        await InvokeAsync(StateHasChanged);
    }

    private void RemoveAttachmentItem(AttachmentItem item)
    {
        _attachmentItems.Remove(item);
        if (item is PendingUploadAttachment pending)
            UploadService.CancelUpload(pending.UploadId);
        StateHasChanged();
    }

    private void RemoveRequestedSkill(string skillId)
    {
        _requestedSkillIds.Remove(skillId);
        StateHasChanged();
    }

    private async Task EditUserMessage(Core.Entities.ChatMessage msg)
    {
        if (_streaming || !ConversationId.HasValue) return;
        var parameters = new DialogParameters
        {
            [nameof(EditMessageDialog.InitialContent)] = msg.Content,
            [nameof(EditMessageDialog.InitialAttachedPaths)] = msg.AttachedPaths,
            [nameof(EditMessageDialog.InitialRequestedSkillIds)] = msg.RequestedSkillIds
        };
        var dialog = await DialogSvc.ShowAsync<EditMessageDialog>("Edit message", parameters, new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true });
        var result = await dialog.Result;
        if (result == null || result.Canceled || result.Data is not EditMessageResult editResult || string.IsNullOrWhiteSpace(editResult.Content)) return;
        _userNameForAction = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(_userNameForAction)) { Snackbar.Add("Username is missing.", Severity.Warning); return; }
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _streamingViews = [];
        _lastStreamActivityAt = null;
        _showWaitingForToolParams = false;
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        _bubbleCountBeforeSend = Bubbles.Count;
        StartWaitingCheckTimer();
        StateHasChanged();
        await OnBeforeSend.InvokeAsync();
        _ = RunReplaceStreamingLoopAsync(msg.Id, editResult.Content.Trim(), editResult.AttachedPaths, editResult.RequestedSkillIds);
    }

    private async Task RegenerateReply(Guid turnId)
    {
        if (_streaming || !ConversationId.HasValue) return;
        _userNameForAction = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(_userNameForAction)) { Snackbar.Add("Username is missing.", Severity.Warning); return; }
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _streamingViews = [];
        _lastStreamActivityAt = null;
        _showWaitingForToolParams = false;
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        _bubbleCountBeforeSend = Bubbles.Count;
        StartWaitingCheckTimer();
        StateHasChanged();
        await OnBeforeSend.InvokeAsync();
        _ = RunRegenerateStreamingLoopAsync(turnId);
    }

    private async Task RunReplaceStreamingLoopAsync(Guid messageId, string newContent, IReadOnlyList<string>? attachedPaths, IReadOnlyList<string>? requestedSkillIds)
    {
        var result = await ConversationPipeline.ReplaceUserMessageAsync(ConversationId!.Value, _userNameForAction!, messageId, newContent, UseThinkingMode, attachedPaths, requestedSkillIds, _sendCts!.Token);
        if (result == null) { _streaming = false;
            await InvokeAsync(StateHasChanged); return; }
        await OnMessageSent.InvokeAsync();
        await RunStreamingLoopForTurnAsync(result.Value.TurnId, result.Value.UserMessage, UseThinkingMode, result.Value.AttachedPaths, result.Value.RequestedSkillIds);
    }

    private async Task RunRegenerateStreamingLoopAsync(Guid turnId)
    {
        var result = await ConversationPipeline.PrepareTurnForRegenerateAsync(ConversationId!.Value, _userNameForAction!, turnId, _sendCts!.Token);
        if (result == null) { _streaming = false;
            await InvokeAsync(StateHasChanged); return; }
        await OnMessageSent.InvokeAsync();
        await RunStreamingLoopForTurnAsync(result.Value.TurnId, result.Value.UserMessage, result.Value.UseThinking, result.Value.AttachedPaths, result.Value.RequestedSkillIds);
    }

    private async Task RunStreamingLoopForTurnAsync(Guid turnId, string userMessage, bool useThinking, IReadOnlyList<string> attachedPaths, IReadOnlyList<string> requestedSkillIds)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, userMessage, useThinking, sink, _sendCts!.Token, CircuitAccessor.CurrentCircuit?.Id, attachedPaths, requestedSkillIds)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts!.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                _lastStreamActivityAt = DateTime.UtcNow;
                _showWaitingForToolParams = false;
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                _streamingViews = Presentation.ConvertStreamingUpdates(_streamingUpdates);
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try { await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, useThinking, "Stopped by user.", CancellationToken.None); persisted = true; } catch { /* ignore */ }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try { await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, useThinking, ex.Message, CancellationToken.None); persisted = true; } catch { /* ignore */ }
            channel.Writer.Complete();
        }
        finally
        {
            StopWaitingCheckTimer();
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _showWaitingForToolParams = false;
            _streamingUpdates.Clear();
            _streamingViews = [];
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string? _userNameForAction;

    private void StopSend()
    {
        _sendCts?.Cancel();
    }

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        // Guard and capture synchronously before any await to prevent double submit (e.g. double-click or Enter+click).
        if (_streaming || _compressing) return;
        var msg = _input.Trim();
        _input = "";

        await OnBeforeSend.InvokeAsync();

        var userName = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(userName))
        {
            Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
            await InvokeAsync(StateHasChanged);
            return;
        }

        // Check and compress context if needed BEFORE creating turn
        _compressing = true;
        _compressionMessage = "Checking context...";
        StateHasChanged();

        try
        {
            var compressed = await ConversationPipeline.CheckAndCompactIfNeededAsync(ConversationId!.Value);
            if (compressed)
            {
                // Compression happened, refresh context display immediately
                await RefreshContextUsageAsync();
            }
        }
        catch (Exception ex)
        {
            Log.LogWarning(ex, "Failed to check/compress context");
        }
        finally
        {
            _compressing = false;
            _compressionMessage = "";
        }

        // Now proceed with sending the message
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _bubbleCountBeforeSend = Bubbles.Count;
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _streamingViews = [];
        _lastStreamActivityAt = null;
        _showWaitingForToolParams = false;
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        StartWaitingCheckTimer();
        StateHasChanged();

        var attachedPaths = _attachmentItems.OfType<ResolvedPathAttachment>().Select(x => x.Path).ToList();
        _attachmentItems.RemoveAll(x => x is ResolvedPathAttachment);
        var requestedSkillIds = _requestedSkillIds.ToList();
        _requestedSkillIds.Clear();
        var turnId = await ConversationPipeline.CreateTurnAndUserMessageAsync(ConversationId!.Value, userName, msg, UseThinkingMode, _sendCts!.Token, attachedPaths, requestedSkillIds);
        _ = RunStreamingLoopAsync(turnId, msg, attachedPaths, requestedSkillIds);
    }

    private async Task RunStreamingLoopAsync(Guid turnId, string msg, IReadOnlyList<string> attachedPaths, IReadOnlyList<string> requestedSkillIds)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var contextId = CircuitAccessor.CurrentCircuit?.Id;
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, msg, UseThinkingMode, sink, _sendCts!.Token, contextId, attachedPaths, requestedSkillIds)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                _lastStreamActivityAt = DateTime.UtcNow;
                _showWaitingForToolParams = false;
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                _streamingViews = Presentation.ConvertStreamingUpdates(_streamingUpdates);
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try
            {
                await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, UseThinkingMode, "Stopped by user.", CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist partial content for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try
            {
                await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, UseThinkingMode, ex.Message, CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist partial content for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        finally
        {
            StopWaitingCheckTimer();
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _pendingUserMessage = "";
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _showWaitingForToolParams = false;
            _streamingUpdates.Clear();
            _streamingViews = [];
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void StartWaitingCheckTimer()
    {
        _waitingCheckTimer?.Dispose();
        _waitingCheckTimer = new Timer(_ => InvokeAsync(RefreshWaitingState), null, 500, 500);
    }

    private void StopWaitingCheckTimer()
    {
        _waitingCheckTimer?.Dispose();
        _waitingCheckTimer = null;
    }

    private void RefreshWaitingState()
    {
        if (!_streaming) return;
        if (_lastStreamActivityAt is null) return;
        var elapsed = (DateTime.UtcNow - _lastStreamActivityAt.Value).TotalSeconds;
        if (!_showWaitingForToolParams && elapsed >= 2)
        {
            _showWaitingForToolParams = true;
            _waitingForToolParamsSince = _lastStreamActivityAt;
            _waitingInReasoning = !_streamingUpdates.Any(u => u is TextStreamUpdate);
        }
        StateHasChanged();
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            if (Bubbles.Count > 0)
                _scrollToBottomRequested = true;
            _contextRefreshRequested = true;
        }
        // When parent refreshes with new turn after streaming, clear streaming state so we show only Bubbles (no duplicate, no flash).
        if (_streaming && Bubbles.Count > _bubbleCountBeforeSend)
        {
            _streaming = false;
            _streamingUpdates.Clear();
            _streamingViews = [];
        }
        RefreshBubbleViews();
    }

    private void RefreshBubbleViews()
    {
        _bubbleViews = Presentation.ConvertBubbles(Bubbles);
        // Update pending bubble if we have a pending message
        if (!string.IsNullOrEmpty(_pendingUserMessage) && !IsPendingMessageAlreadyInBubbles())
        {
            _pendingUserBubble = new UserBubbleView
            {
                MessageId = Guid.Empty,
                Content = _pendingUserMessage,
                CreatedAt = _pendingUserMessageTime,
                IsEdited = false,
                AttachedPaths = [],
                RequestedSkillIds = []
            };
        }
        else
        {
            _pendingUserBubble = null;
        }
    }

    private async Task HandleEditMessage(UserBubbleView userBubble)
    {
        // Find the original message from Bubbles to get the ChatMessage entity
        var originalBubble = Bubbles.OfType<UserBubble>().FirstOrDefault(b => b.Message.Id == userBubble.MessageId);
        if (originalBubble?.Message is { } msg)
        {
            await EditUserMessage(msg);
        }
    }

    private async Task HandleRegenerateReply(Guid turnId)
    {
        await RegenerateReply(turnId);
    }

    private bool _contextRefreshRequested;

    protected override async Task OnParametersSetAsync()
    {
        if (_contextRefreshRequested && ConversationId.HasValue)
        {
            _contextRefreshRequested = false;
            try
            {
                var d = await AgentCache.GetEstimatedContextUsageDetailAsync(ConversationId.Value);
                if (d != null)
                {
                    _contextPercentText = $"{d.Ratio:P1}";
                    _contextUsageTooltip = $"Context: {d.Ratio:P1} · {AgentCacheService.FormatTokenCount(d.UsedTokens)}/{AgentCacheService.FormatTokenCount(d.ContextWindowTokens)}";
                }
                else
                {
                    _contextPercentText = "—";
                    _contextUsageTooltip = null;
                }
            }
            catch
            {
                _contextPercentText = "—";
                _contextUsageTooltip = null;
            }
        }
        else if (!ConversationId.HasValue)
        {
            _contextPercentText = "—";
            _contextUsageTooltip = null;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dropZoneDotNetRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.attachDropZone", "smallebot-chat-drop-zone", _dropZoneDotNetRef);
            }
            catch (Exception ex)
            {
                Log.LogWarning(ex, "Failed to attach drop zone");
                _dropZoneDotNetRef?.Dispose();
                _dropZoneDotNetRef = null;
            }
            // Subscribe to compression events from ConversationPipeline
            ConversationPipeline.CompressionStarted += OnCompressionStarted;
            ConversationPipeline.CompressionCompleted += OnCompressionCompleted;
            // Subscribe to model config changes to refresh context display
            ModelConfigService.OnChanged += OnModelConfigChanged;
        }
        if (_scrollToBottomRequested)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
        if (_moveCursorToEnd)
        {
            _moveCursorToEnd = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.setChatInputValueAndCursorToEnd", "smallebot-chat-input-wrap", _input);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    [JSInvokable]
    public async Task<string?> StartUploadFromDrop(string fileName, long contentLength)
    {
        var ext = Path.GetExtension(fileName);
        if (!AllowedFileExtensions.IsAllowed(ext))
        {
            Snackbar.Add("Extension not allowed", Severity.Warning);
            return null;
        }
        var uploadId = await UploadService.StartUploadAsync(fileName, contentLength);
        _attachmentItems.Add(new PendingUploadAttachment(uploadId, fileName));
        await InvokeAsync(StateHasChanged);
        return uploadId;
    }

    [JSInvokable]
    public async Task ReportChunkAsync(string uploadId, string base64Chunk)
    {
        var chunk = Convert.FromBase64String(base64Chunk);
        await UploadService.ReportChunkAsync(uploadId, chunk);
    }

    [JSInvokable]
    public void ReportUploadProgress(string uploadId, int progress)
    {
        var pending = _attachmentItems.OfType<PendingUploadAttachment>().FirstOrDefault(p => p.UploadId == uploadId);
        if (pending != null)
        {
            pending.Progress = progress;
            _ = InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task CompleteUploadAsync(string uploadId)
    {
        var result = await UploadService.CompleteUploadAsync(uploadId);
        var idx = _attachmentItems.FindIndex(x => x is PendingUploadAttachment p && p.UploadId == uploadId);
        if (idx >= 0)
            _attachmentItems.RemoveAt(idx);
        if (result != null)
        {
            if (result.ReplacedOldPath != null)
                _attachmentItems.RemoveAll(x => x is ResolvedPathAttachment r && r.Path == result.ReplacedOldPath);
            if (_attachmentItems.OfType<ResolvedPathAttachment>().All(r => r.Path != result.Path))
                _attachmentItems.Add(new ResolvedPathAttachment(result.Path));
        }
        else
            Snackbar.Add("Upload failed", Severity.Error);
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>True if the last user message in Bubbles has the same content as _pendingUserMessage (avoids duplicate bubble when refresh and pending overlap).</summary>
    private bool IsPendingMessageAlreadyInBubbles()
    {
        if (string.IsNullOrEmpty(_pendingUserMessage) || Bubbles.Count == 0) return false;
        var lastUser = Bubbles.OfType<UserBubble>().LastOrDefault();
        return lastUser?.Message.Content.Trim() == _pendingUserMessage.Trim();
    }

    private void OnCompressionStarted(Guid conversationId)
    {
        if (conversationId != ConversationId) return;
        _compressing = true;
        _compressionMessage = "Compressing context...";
        InvokeAsync(StateHasChanged);
    }

    private void OnCompressionCompleted(Guid conversationId, bool success)
    {
        if (conversationId != ConversationId) return;
        _compressing = false;
        _compressionMessage = success ? "Context compressed" : "Compression failed";
        // Clear message after a delay
        _ = Task.Run(async () =>
        {
            await Task.Delay(2000);
            _compressionMessage = "";
            await InvokeAsync(StateHasChanged);
        });
        // Refresh context usage after compression
        _ = InvokeAsync(RefreshContextUsageAsync);
    }

    private async Task RefreshContextUsageAsync()
    {
        if (!ConversationId.HasValue) return;
        try
        {
            var d = await AgentCache.GetEstimatedContextUsageDetailAsync(ConversationId.Value);
            if (d != null)
            {
                _contextPercentText = $"{d.Ratio:P1}";
                _contextUsageTooltip = $"Context: {d.Ratio:P1} · {AgentCacheService.FormatTokenCount(d.UsedTokens)}/{AgentCacheService.FormatTokenCount(d.ContextWindowTokens)}";
            }
            else
            {
                _contextPercentText = "—";
                _contextUsageTooltip = null;
            }
            StateHasChanged();
        }
        catch
        {
            _contextPercentText = "—";
            _contextUsageTooltip = null;
        }
    }

    private void OnModelConfigChanged()
    {
        // Model changed, refresh context display (different models have different context windows)
        _ = InvokeAsync(async () =>
        {
            await AgentCache.InvalidateAgentAsync();
            await RefreshContextUsageAsync();
        });
    }

    public void Dispose()
    {
        StopWaitingCheckTimer();
        ConversationPipeline.CompressionStarted -= OnCompressionStarted;
        ConversationPipeline.CompressionCompleted -= OnCompressionCompleted;
        ModelConfigService.OnChanged -= OnModelConfigChanged;
        try { _ = JS.InvokeVoidAsync("SmallEBot.detachDropZone", "smallebot-chat-drop-zone"); } catch { /* ignore */ }
        _dropZoneDotNetRef?.Dispose();
        _dropZoneDotNetRef = null;
    }
}
