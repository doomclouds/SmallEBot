@using System.IO
@using SmallEBot.Application.Conversation
@using SmallEBot.Application.Streaming
@using SmallEBot.Core
@using SmallEBot.Core.Models
@using SmallEBot.Models
@using SmallEBot.Services.Circuit
@inject IAgentConversationService ConversationPipeline
@inject IDialogService DialogSvc
@inject IWorkspaceUploadService UploadService
@inject ICurrentCircuitAccessor CircuitAccessor
@inject AgentCacheService AgentCache
@inject UserNameService UserNameSvc
@inject IWorkspaceService WorkspaceService
@inject ISkillsConfigService SkillsConfigService
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject ILogger<ChatArea> Log
@implements IDisposable

<MudPaper Class="pa-4 pb-1 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Bubbles.Any())
    {
        @foreach (var bubble in Bubbles)
        {
            @if (bubble is UserBubble userBubble)
            {
                var msg = userBubble.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <div class="d-flex justify-space-between align-start gap-1">
                            <div style="flex: 1">
                                <MudText Typo="Typo.caption">You Â· @msg.CreatedAt.ToString("g")@(msg.IsEdited ? " (edited)" : "")</MudText>
                                @if (!string.IsNullOrEmpty(msg.Content))
                                {
                                    <MarkdownContentView Content="@msg.Content" />
                                }
                            </div>
                            <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => EditUserMessage(msg))" title="Edit" />
                        </div>
                    </MudChatBubble>
                </MudChat>
            }
            else if (bubble is AssistantBubble asstBubble)
            {
                var blocks = ReasoningSegmenter.SegmentTurn(asstBubble.Items, asstBubble.IsThinkingMode);
                var firstCreatedAt = asstBubble.Items.Count > 0 ? asstBubble.Items[0].CreatedAt : DateTime.UtcNow;
                var isError = IsErrorReply(asstBubble.Items);
                var bubbleClass = isError ? "mb-3 smallebot-bubble smallebot-assistant-error" : "mb-3 smallebot-bubble";
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="@bubbleClass">
                    <MudChatBubble>
                        <div class="d-flex justify-space-between align-start gap-1">
                            <div style="flex: 1">
                                <MudText Typo="Typo.caption">SmallEBot Â· @firstCreatedAt.ToString("g")</MudText>
                        @foreach (var block in blocks)
                        {
                            @if (block.IsThinkBlock)
                            {
                                var stepViews = block.Items.Select(TimelineItemToReasoningStepView).Where(x => x != null).Cast<ReasoningStepView>().ToList();
                                var toolCount = stepViews.Count(x => !x.IsThink);
                                var panelTitle = toolCount > 0 ? $"ðŸ’­ Reasoning ({toolCount} tool calls)" : "ðŸ’­ Reasoning";
                                <MudExpansionPanels Class="mt-2" Elevation="0">
                                    <MudExpansionPanel expanded="false" Text="@panelTitle">
                                        <div class="d-flex flex-column gap-2">
                                            <ReasoningBlockView Steps="@stepViews" />
                                        </div>
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            }
                            else
                            {
                                @foreach (var item in block.Items)
                                {
                                    @if (item.Message is { } msg && !string.IsNullOrEmpty(msg.Content))
                                    {
                                        <MarkdownContentView Content="@msg.Content" />
                                    }
                                    else if (item.ThinkBlock is { } tb && !string.IsNullOrEmpty(tb.Content))
                                    {
                                        <MarkdownContentView Content="@tb.Content" />
                                    }
                                    else if (item.ToolCall is { } tc && ShowToolCalls)
                                    {
                                        <ToolCallView ToolName="@tc.ToolName" ToolArguments="@tc.Arguments" ToolResult="@tc.Result" ShowToolCalls="@ShowToolCalls" />
                                    }
                                }
                            }
                        }
                            </div>
                            @if (asstBubble.TurnId != Guid.Empty)
                            {
                                <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" OnClick="@(() => RegenerateReply(asstBubble.TurnId))" title="Regenerate" />
                            }
                        </div>
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages. Hide if already in Bubbles to avoid duplicate (H5). *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage) && !IsPendingMessageAlreadyInBubbles())
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You Â· @_pendingUserMessageTime.ToString("g")</MudText>
                <MarkdownContentView Content="@_pendingUserMessage" />
            </MudChatBubble>
        </MudChat>
    }
    @* Only show streaming block while actively streaming; after persist parent refresh shows reply from Bubbles (avoids duplicate AI bubble). *@
    @if (_streaming)
    {
        <StreamingMessageView Items="@GetStreamingDisplayItemViews()"
                              FallbackText="@_streamingText"
                              Timestamp="@DateTime.Now" />
    }
    </div>

    <div id="smallebot-chat-drop-zone" class="position-relative mt-2">
        @* Chips for @ (files) and / (skills); different colors, closable. Input does not show path or skill text. *@
        <AttachmentPopover @ref="_attachmentPopoverRef"
                          @bind-Open="_popoverOpen"
                          Kind="@_popoverKind"
                          Filter="@_popoverFilter"
                          FilePaths="@_filePaths"
                          Skills="@_skills"
                          OnSelect="@OnAttachmentSelected" />
        @if (_attachmentItems.Count > 0 || _requestedSkillIds.Count > 0)
        {
            <div class="d-flex flex-wrap align-items-center gap-1 mb-2">
                @foreach (var item in _attachmentItems)
                {
                    @if (item is ResolvedPathAttachment r)
                    {
                        <MudChip T="object" Color="Color.Primary" Variant="Variant.Filled" OnClose="@(() => RemoveAttachmentItem(r))" CloseIcon="@Icons.Material.Filled.Cancel">
                            @r.Path
                        </MudChip>
                    }
                    else if (item is PendingUploadAttachment p)
                    {
                        <MudChip T="object" Color="Color.Primary" Variant="Variant.Filled" OnClose="@(() => RemoveAttachmentItem(p))" CloseIcon="@Icons.Material.Filled.Cancel">
                            <MudProgressCircular Size="Size.Small" Indeterminate="@(p.Progress <= 0 || p.Progress >= 100)" Value="@p.Progress" />
                            @p.DisplayName
                        </MudChip>
                    }
                }
                @foreach (var skillId in _requestedSkillIds)
                {
                    <MudChip T="object" Color="Color.Secondary" Variant="Variant.Filled" OnClose="@(() => RemoveRequestedSkill(skillId))" CloseIcon="@Icons.Material.Filled.Cancel">
                        /@skillId
                    </MudChip>
                }
            </div>
        }
        <ChatInputBar Value="@_input"
                      ValueChanged="HandleInputChanged"
                      Streaming="_streaming"
                      ContextPercentText="@_contextPercentText"
                      ContextUsageTooltip="@_contextUsageTooltip"
                      OnSend="Send"
                      OnStop="StopSend"
                      Disabled="@(string.IsNullOrWhiteSpace(_input) || _attachmentItems.OfType<PendingUploadAttachment>().Any())"
                      Class="" />
    </div>
</MudPaper>

@code {
    [Parameter] public List<ChatBubble> Bubbles { get; set; } = [];
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; }

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private readonly List<StreamUpdate> _streamingUpdates = [];
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>Bubble count at start of Send(); used to detect when parent has refreshed with new turn so we clear streaming without a visible flash.</summary>
    private int _bubbleCountBeforeSend;
    private CancellationTokenSource? _sendCts;
    private string _contextPercentText = "0%";
    private string? _contextUsageTooltip;
    private bool _popoverOpen;
    private string _popoverKind = "file";
    private string _popoverFilter = "";
    private IReadOnlyList<string> _filePaths = [];
    private IReadOnlyList<SkillMetadata> _skills = [];
    private bool _moveCursorToEnd;
    private readonly List<AttachmentItem> _attachmentItems = [];
    private readonly List<string> _requestedSkillIds = [];
    private AttachmentPopover? _attachmentPopoverRef;
    private bool _suggestionKeysAttached;
    private DotNetObjectReference<ChatArea>? _suggestionKeysDotNetRef;
    private DotNetObjectReference<ChatArea>? _dropZoneDotNetRef;
    private bool _justSelectedAttachment;

    private async Task HandleInputChanged(string v)
    {
        if (_justSelectedAttachment)
        {
            _justSelectedAttachment = false;
            return;
        }
        _input = v;
        var lastAt = v.LastIndexOf('@');
        var lastSlash = v.LastIndexOf('/');
        if (lastSlash > lastAt)
        {
            _popoverKind = "skill";
            _popoverOpen = true;
            _popoverFilter = lastSlash + 1 < v.Length ? v[(lastSlash + 1)..] : "";
            if (_skills.Count == 0)
                _skills = await SkillsConfigService.GetMetadataForAgentAsync();
        }
        else if (lastAt >= 0)
        {
            _popoverKind = "file";
            _popoverOpen = true;
            _popoverFilter = lastAt + 1 < v.Length ? v[(lastAt + 1)..] : "";
            if (_filePaths.Count == 0)
                _filePaths = await WorkspaceService.GetAllowedFilePathsAsync();
        }
        else
        {
            ClosePopover();
        }
        StateHasChanged();
    }

    private void ClosePopover()
    {
        _popoverOpen = false;
    }

    private async Task OnAttachmentSelected(string value)
    {
        if (_popoverKind == "file")
        {
            if (_attachmentItems.OfType<ResolvedPathAttachment>().All(x => x.Path != value))
                _attachmentItems.Add(new ResolvedPathAttachment(value));
            var lastAt = _input.LastIndexOf('@');
            _input = lastAt >= 0 ? _input[..lastAt].TrimEnd() : _input;
        }
        else
        {
            if (!_requestedSkillIds.Any(s => string.Equals(s, value, StringComparison.OrdinalIgnoreCase)))
                _requestedSkillIds.Add(value);
            var lastSlash = _input.LastIndexOf('/');
            _input = lastSlash >= 0 ? _input[..lastSlash].TrimEnd() : _input;
        }
        if (_input.Length > 0 && !_input.EndsWith(' '))
            _input += " ";
        _justSelectedAttachment = true;
        ClosePopover();
        _moveCursorToEnd = true;
        await InvokeAsync(StateHasChanged);
    }

    private void RemoveAttachmentItem(AttachmentItem item)
    {
        _attachmentItems.Remove(item);
        if (item is PendingUploadAttachment pending)
            UploadService.CancelUpload(pending.UploadId);
        StateHasChanged();
    }

    private void RemoveRequestedSkill(string skillId)
    {
        _requestedSkillIds.Remove(skillId);
        StateHasChanged();
    }

    private async Task EditUserMessage(SmallEBot.Core.Entities.ChatMessage msg)
    {
        if (_streaming || !ConversationId.HasValue) return;
        var parameters = new DialogParameters { [nameof(EditMessageDialog.InitialContent)] = msg.Content };
        var dialog = await DialogSvc.ShowAsync<EditMessageDialog>("Edit message", parameters);
        var result = await dialog.Result;
        if (result == null || result.Canceled || result.Data is not string newContent || string.IsNullOrWhiteSpace(newContent)) return;
        _userNameForAction = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(_userNameForAction)) { Snackbar.Add("Username is missing.", Severity.Warning); return; }
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        _bubbleCountBeforeSend = Bubbles.Count;
        StateHasChanged();
        await OnBeforeSend.InvokeAsync();
        _ = RunReplaceStreamingLoopAsync(msg.Id, newContent.Trim());
    }

    private async Task RegenerateReply(Guid turnId)
    {
        if (_streaming || !ConversationId.HasValue) return;
        _userNameForAction = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(_userNameForAction)) { Snackbar.Add("Username is missing.", Severity.Warning); return; }
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        _bubbleCountBeforeSend = Bubbles.Count;
        StateHasChanged();
        await OnBeforeSend.InvokeAsync();
        _ = RunRegenerateStreamingLoopAsync(turnId);
    }

    private async Task RunReplaceStreamingLoopAsync(Guid messageId, string newContent)
    {
        var result = await ConversationPipeline.ReplaceUserMessageAsync(ConversationId!.Value, _userNameForAction!, messageId, newContent, UseThinkingMode, _sendCts!.Token);
        if (result == null) { _streaming = false; await InvokeAsync(StateHasChanged); return; }
        await OnMessageSent.InvokeAsync();
        await RunStreamingLoopForTurnAsync(result.Value.TurnId, result.Value.UserMessage, UseThinkingMode);
    }

    private async Task RunRegenerateStreamingLoopAsync(Guid turnId)
    {
        var result = await ConversationPipeline.PrepareTurnForRegenerateAsync(ConversationId!.Value, _userNameForAction!, turnId, _sendCts!.Token);
        if (result == null) { _streaming = false; await InvokeAsync(StateHasChanged); return; }
        await OnMessageSent.InvokeAsync();
        await RunStreamingLoopForTurnAsync(result.Value.TurnId, result.Value.UserMessage, result.Value.UseThinking);
    }

    private async Task RunStreamingLoopForTurnAsync(Guid turnId, string userMessage, bool useThinking)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, userMessage, useThinking, sink, _sendCts!.Token, CircuitAccessor.CurrentCircuit?.Id, null, null)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts!.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try { await ConversationPipeline.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, "Stopped by user.", CancellationToken.None); persisted = true; } catch { /* ignore */ }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try { await ConversationPipeline.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, ex.Message, CancellationToken.None); persisted = true; } catch { /* ignore */ }
            channel.Writer.Complete();
        }
        finally
        {
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _streamingUpdates.Clear();
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string? _userNameForAction;

    private void StopSend()
    {
        _sendCts?.Cancel();
    }

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        // Guard and capture synchronously before any await to prevent double submit (e.g. double-click or Enter+click).
        if (_streaming) return;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _bubbleCountBeforeSend = Bubbles.Count;
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        StateHasChanged();

        await OnBeforeSend.InvokeAsync();

        var userName = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(userName))
        {
            Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
            _pendingUserMessage = "";
            _streaming = false;
            _sendCts?.Dispose();
            _sendCts = null;
            await InvokeAsync(StateHasChanged);
            return;
        }

        var attachedPaths = _attachmentItems.OfType<ResolvedPathAttachment>().Select(x => x.Path).ToList();
        _attachmentItems.RemoveAll(x => x is ResolvedPathAttachment);
        var requestedSkillIds = _requestedSkillIds.ToList();
        _requestedSkillIds.Clear();
        var turnId = await ConversationPipeline.CreateTurnAndUserMessageAsync(ConversationId!.Value, userName, msg, UseThinkingMode, _sendCts!.Token, attachedPaths, requestedSkillIds);
        _ = RunStreamingLoopAsync(turnId, msg, attachedPaths, requestedSkillIds);
    }

    private async Task RunStreamingLoopAsync(Guid turnId, string msg, IReadOnlyList<string> attachedPaths, IReadOnlyList<string> requestedSkillIds)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var contextId = CircuitAccessor.CurrentCircuit?.Id;
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, msg, UseThinkingMode, sink, _sendCts!.Token, contextId, attachedPaths, requestedSkillIds)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try
            {
                await ConversationPipeline.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, "Stopped by user.", CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist stop message for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try
            {
                await ConversationPipeline.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, ex.Message, CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist error message for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        finally
        {
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _pendingUserMessage = "";
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _streamingUpdates.Clear();
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            if (Bubbles.Count > 0)
                _scrollToBottomRequested = true;
            _contextRefreshRequested = true;
        }
        // When parent refreshes with new turn after streaming, clear streaming state so we show only Bubbles (no duplicate, no flash).
        if (_streaming && Bubbles.Count > _bubbleCountBeforeSend)
        {
            _streaming = false;
            _streamingUpdates.Clear();
        }
    }

    private bool _contextRefreshRequested;

    protected override async Task OnParametersSetAsync()
    {
        if (_contextRefreshRequested && ConversationId.HasValue)
        {
            _contextRefreshRequested = false;
            try
            {
                var d = await AgentCache.GetEstimatedContextUsageDetailAsync(ConversationId.Value);
                if (d != null)
                {
                    _contextPercentText = $"{d.Ratio:P1}";
                    _contextUsageTooltip = $"Context: {d.Ratio:P1} Â· {AgentCacheService.FormatTokenCount(d.UsedTokens)}/{AgentCacheService.FormatTokenCount(d.ContextWindowTokens)}";
                }
                else
                {
                    _contextPercentText = "â€”";
                    _contextUsageTooltip = null;
                }
            }
            catch
            {
                _contextPercentText = "â€”";
                _contextUsageTooltip = null;
            }
        }
        else if (!ConversationId.HasValue)
        {
            _contextPercentText = "â€”";
            _contextUsageTooltip = null;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dropZoneDotNetRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.attachDropZone", "smallebot-chat-drop-zone", _dropZoneDotNetRef);
            }
            catch (Exception ex)
            {
                Log.LogWarning(ex, "Failed to attach drop zone");
                _dropZoneDotNetRef?.Dispose();
                _dropZoneDotNetRef = null;
            }
        }
        if (_scrollToBottomRequested)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
        if (_moveCursorToEnd)
        {
            _moveCursorToEnd = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.setChatInputValueAndCursorToEnd", "smallebot-chat-input-wrap", _input);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
        if (_popoverOpen && !_suggestionKeysAttached)
        {
            _suggestionKeysAttached = true;
            _suggestionKeysDotNetRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.attachChatInputSuggestionKeys", "smallebot-chat-input-wrap", _suggestionKeysDotNetRef);
            }
            catch
            {
                _suggestionKeysAttached = false;
                _suggestionKeysDotNetRef?.Dispose();
                _suggestionKeysDotNetRef = null;
            }
        }
        else if (!_popoverOpen && _suggestionKeysAttached)
        {
            _suggestionKeysAttached = false;
            try { await JS.InvokeVoidAsync("SmallEBot.detachChatInputSuggestionKeys", "smallebot-chat-input-wrap"); } catch { /* ignore */ }
            _suggestionKeysDotNetRef?.Dispose();
            _suggestionKeysDotNetRef = null;
        }
    }

    [JSInvokable]
    public async Task<string?> StartUploadFromDrop(string fileName, long contentLength)
    {
        var ext = Path.GetExtension(fileName);
        if (!AllowedFileExtensions.IsAllowed(ext))
        {
            Snackbar.Add("Extension not allowed", Severity.Warning);
            return null;
        }
        var uploadId = await UploadService.StartUploadAsync(fileName, contentLength);
        _attachmentItems.Add(new PendingUploadAttachment(uploadId, fileName));
        await InvokeAsync(StateHasChanged);
        return uploadId;
    }

    [JSInvokable]
    public async Task ReportChunkAsync(string uploadId, string base64Chunk)
    {
        var chunk = Convert.FromBase64String(base64Chunk);
        await UploadService.ReportChunkAsync(uploadId, chunk);
    }

    [JSInvokable]
    public void ReportUploadProgress(string uploadId, int progress)
    {
        var pending = _attachmentItems.OfType<PendingUploadAttachment>().FirstOrDefault(p => p.UploadId == uploadId);
        if (pending != null)
        {
            pending.Progress = progress;
            _ = InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task CompleteUploadAsync(string uploadId)
    {
        var result = await UploadService.CompleteUploadAsync(uploadId);
        var idx = _attachmentItems.FindIndex(x => x is PendingUploadAttachment p && p.UploadId == uploadId);
        if (idx >= 0)
            _attachmentItems.RemoveAt(idx);
        if (result != null)
        {
            if (result.ReplacedOldPath != null)
                _attachmentItems.RemoveAll(x => x is ResolvedPathAttachment r && r.Path == result.ReplacedOldPath);
            if (_attachmentItems.OfType<ResolvedPathAttachment>().All(r => r.Path != result.Path))
                _attachmentItems.Add(new ResolvedPathAttachment(result.Path));
        }
        else
            Snackbar.Add("Upload failed", Severity.Error);
        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnSuggestionKeyDown(string key)
    {
        if (_attachmentPopoverRef != null)
            await _attachmentPopoverRef.HandleKeyFromInputAsync(key);
    }

    /// <summary>True if the last user message in Bubbles has the same content as _pendingUserMessage (avoids duplicate bubble when refresh and pending overlap).</summary>
    private bool IsPendingMessageAlreadyInBubbles()
    {
        if (string.IsNullOrEmpty(_pendingUserMessage) || Bubbles.Count == 0) return false;
        var lastUser = Bubbles.OfType<UserBubble>().LastOrDefault();
        return lastUser?.Message.Content.Trim() == _pendingUserMessage.Trim();
    }

    /// <summary>Detects if the assistant bubble is a single error message (Content starts with "Error: ").</summary>
    private static bool IsErrorReply(IReadOnlyList<TimelineItem> items)
    {
        if (items.Count != 1) return false;
        var item = items[0];
        return item.Message is { Role: "assistant" } msg && msg.Content.StartsWith("Error: ", StringComparison.Ordinal);
    }

    public void Dispose()
    {
        try { _ = JS.InvokeVoidAsync("SmallEBot.detachDropZone", "smallebot-chat-drop-zone"); } catch { /* ignore */ }
        _dropZoneDotNetRef?.Dispose();
        _dropZoneDotNetRef = null;
        _suggestionKeysDotNetRef?.Dispose();
    }
}
