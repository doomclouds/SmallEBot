@using SmallEBot.Data.Entities
@using SmallEBot.Models
@inject AgentService AgentSvc
@inject UserNameService UserNameSvc
@inject MarkdownService MarkdownSvc
@inject IJSRuntime JS
@inject ISnackbar Snackbar

<MudPaper Class="pa-4 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Groups.Any())
    {
        @foreach (var group in Groups)
        {
            @if (group is UserMessageGroup userGroup)
            {
                var msg = userGroup.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">You 路 @msg.CreatedAt.ToString("g")</MudText>
                        @if (!string.IsNullOrEmpty(msg.Content))
                        {
                            <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(msg.Content))</div>
                        }
                    </MudChatBubble>
                </MudChat>
            }
            else if (group is AssistantMessageGroup asstGroup)
            {
                var firstCreatedAt = asstGroup.Items.Count > 0 ? asstGroup.Items[0].CreatedAt : DateTime.UtcNow;
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">SmallEBot 路 @firstCreatedAt.ToString("g")</MudText>
                        @foreach (var item in asstGroup.Items)
                        {
                            @if (item.Message != null)
                            {
                                @if (!string.IsNullOrEmpty(item.Message.Content))
                                {
                                    <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(item.Message.Content))</div>
                                }
                            }
                            else if (item.ToolCall != null && ShowToolCalls)
                            {
                                var tool = item.ToolCall;
                                <MudExpansionPanels Class="mt-2" Elevation="0">
                                    <MudExpansionPanel expanded="false" Text="@($" {tool.ToolName}")">
                                        @if (!string.IsNullOrEmpty(tool.Arguments))
                                        {
                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@tool.Arguments</pre></div>
                                        }
                                        @if (!string.IsNullOrEmpty(tool.Result))
                                        {
                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@tool.Result</pre></div>
                                        }
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            }
                        }
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage))
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You 路 @_pendingUserMessageTime.ToString("g")</MudText>
                <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(_pendingUserMessage))</div>
            </MudChatBubble>
        </MudChat>
    }
    @if (_streaming || _showLastStreamedReply)
    {
        <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">SmallEBot 路 @DateTime.Now.ToString("g")</MudText>
                @foreach (var item in GetStreamingDisplayItems())
                {
                    if (item.IsText)
                    {
                        <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(item.Text))</div>
                    }
                    else if (ShowToolCalls)
                    {
                        <MudExpansionPanels Class="mt-2" Elevation="0">
                            <MudExpansionPanel expanded="false" Text="@($" {item.ToolName ?? "Tool"}")">
                                @if (!string.IsNullOrEmpty(item.ToolArguments))
                                {
                                    <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@item.ToolArguments</pre></div>
                                }
                                @if (!string.IsNullOrEmpty(item.ToolResult))
                                {
                                    <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@item.ToolResult</pre></div>
                                }
                            </MudExpansionPanel>
                        </MudExpansionPanels>
                    }
                }
                @if (!GetStreamingDisplayItems().Any() && !string.IsNullOrEmpty(_streamingText))
                {
                    <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(_streamingText))</div>
                }
            </MudChatBubble>
        </MudChat>
    }
    </div>

    <MudStack Row="true" Spacing="2" Class="mt-4">
        <MudTextField @bind-Value="_input"
                      Label="Message"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      OnKeyDown="@OnKeyDown" />
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="@Send"
                   Disabled="@(_streaming || string.IsNullOrWhiteSpace(_input))">
            Send
        </MudButton>
    </MudStack>
</MudPaper>

@code {
    [Parameter] public List<MessageGroup> Groups { get; set; } = new();
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; } = false;

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private List<StreamUpdate> _streamingUpdates = [];
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>True after persist: show last streamed reply without refetching (avoids full re-render). Cleared when conversation changes or next send.</summary>
    private bool _showLastStreamedReply;

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        await OnBeforeSend.InvokeAsync();
        _showLastStreamedReply = false;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _scrollToBottomRequested = true;
        StateHasChanged();

        var persisted = false;
        try
        {
            var userName = UserNameSvc.CurrentDisplayName ?? UserName;
            if (string.IsNullOrWhiteSpace(userName))
            {
                Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
                _pendingUserMessage = "";
                _streaming = false;
                await InvokeAsync(StateHasChanged);
                return;
            }
            await foreach (var update in AgentSvc.SendMessageStreamingAsync(ConversationId!.Value, msg, UseThinkingMode))
            {
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                    default:
                        break;
                }
                _scrollToBottomRequested = true;
                StateHasChanged();
            }
            var items = GetStreamingDisplayItems().ToList();
            var segments = items.Count > 0
                ? items.Select(x => x.IsText
                    ? new AssistantSegment(true, Text: x.Text)
                    : new AssistantSegment(false, ToolName: x.ToolName, Arguments: x.ToolArguments, Result: x.ToolResult)).ToList()
                : (!string.IsNullOrEmpty(_streamingText) ? [new AssistantSegment(true, Text: _streamingText)] : []);
            await AgentSvc.PersistMessagesAsync(ConversationId!.Value, userName, msg, segments);
            persisted = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            if (persisted)
            {
                await OnMessageSent.InvokeAsync();
                _pendingUserMessage = "";
                _showLastStreamedReply = true;
            }
            _streaming = false;
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            _showLastStreamedReply = false;
            if (Groups.Count > 0)
                _scrollToBottomRequested = true;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollToBottomRequested || _streaming)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e is { Key: "Enter", ShiftKey: false }) await Send();
    }

    private sealed class StreamDisplayItem
    {
        public bool IsText { get; init; }
        public string? Text { get; init; }
        public string? ToolName { get; init; }
        public string? ToolArguments { get; init; }
        public string? ToolResult { get; set; }
    }

    private IEnumerable<StreamDisplayItem> GetStreamingDisplayItems()
    {
        var list = new List<StreamDisplayItem>();
        foreach (var update in _streamingUpdates)
        {
            if (update is TextStreamUpdate t)
            {
                if (list.Count > 0 && list[^1] is { IsText: true } lastText)
                    list[list.Count - 1] = new StreamDisplayItem { IsText = true, Text = (lastText.Text ?? "") + t.Text };
                else
                    list.Add(new StreamDisplayItem { IsText = true, Text = t.Text });
                continue;
            }
            if (update is ToolCallStreamUpdate tc)
            {
                if (tc.Result != null && tc.Arguments == null)
                {
                    var lastTool = list.LastOrDefault(x => !x.IsText);
                    if (lastTool != null)
                        lastTool.ToolResult = tc.Result;
                }
                else if (!string.IsNullOrEmpty(tc.ToolName) || tc.Arguments != null)
                {
                    list.Add(new StreamDisplayItem { IsText = false, ToolName = tc.ToolName, ToolArguments = tc.Arguments, ToolResult = tc.Result });
                }
            }
        }
        return list;
    }
}
