@using SmallEBot.Models
@inject AgentService AgentSvc
@inject UserNameService UserNameSvc
@inject MarkdownService MarkdownSvc
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject ILogger<ChatArea> Log

<MudPaper Class="pa-4 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Groups.Any())
    {
        @foreach (var group in Groups)
        {
            @if (group is UserMessageGroup userGroup)
            {
                var msg = userGroup.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">You ¬∑ @msg.CreatedAt.ToString("g")</MudText>
                        @if (!string.IsNullOrEmpty(msg.Content))
                        {
                            <MarkdownContentView Content="@msg.Content" />
                        }
                    </MudChatBubble>
                </MudChat>
            }
            else if (group is AssistantMessageGroup asstGroup)
            {
                var result = ReasoningSegmenter.SegmentTurn(asstGroup.Items, asstGroup.IsThinkingMode);
                var firstCreatedAt = asstGroup.Items.Count > 0 ? asstGroup.Items[0].CreatedAt : DateTime.UtcNow;
                var isError = IsErrorReply(asstGroup.Items);
                var bubbleClass = isError ? "mb-3 smallebot-bubble smallebot-assistant-error" : "mb-3 smallebot-bubble";
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="@bubbleClass">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">SmallEBot ¬∑ @firstCreatedAt.ToString("g")</MudText>
                        @foreach (var block in result.ReasoningBlocks)
                        {
                            var toolCount = block.Count(x => !x.IsThink);
                            var panelTitle = toolCount > 0 ? $"üí≠ Êé®ÁêÜËøáÁ®ã (Âê´ {toolCount} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®)" : "üí≠ Êé®ÁêÜËøáÁ®ã";
                            <MudExpansionPanels Class="mt-2" Elevation="0">
                                <MudExpansionPanel expanded="false" Text="@panelTitle">
                                    <div class="d-flex flex-column gap-2">
                                        @foreach (var step in block)
                                        {
                                            if (step.IsThink)
                                            {
                                                <div class="smallebot-reasoning-step">
                                                    <MudText Typo="Typo.caption" Class="mb-1 smallebot-reasoning-label">ÊÄùËÄÉ</MudText>
                                                    @if (!string.IsNullOrEmpty(step.Text))
                                                    {
                                                        <MarkdownContentView Content="@step.Text" CssClass="smallebot-reasoning-body" />
                                                    }
                                                </div>
                                            }
                                            else if (ShowToolCalls)
                                            {
                                                <div class="smallebot-reasoning-step">
                                                    <MudExpansionPanels Elevation="0" Class="pa-0">
                                                        <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                                            @if (!string.IsNullOrEmpty(step.ToolArguments))
                                                            {
                                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                                            }
                                                            @if (!string.IsNullOrEmpty(step.ToolResult))
                                                            {
                                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                                            }
                                                        </MudExpansionPanel>
                                                    </MudExpansionPanels>
                                                </div>
                                            }
                                        }
                                    </div>
                                </MudExpansionPanel>
                            </MudExpansionPanels>
                        }
                        @foreach (var seg in result.ReplySegments)
                        {
                            @if (seg.IsText && !string.IsNullOrEmpty(seg.Text))
                            {
                                <MarkdownContentView Content="@seg.Text" />
                            }
                            else if (!seg.IsText && ShowToolCalls)
                            {
                                <div class="mt-2">
                                    <MudExpansionPanels Elevation="0" Class="pa-0">
                                        <MudExpansionPanel expanded="false" Text="@($"üîß {seg.ToolName ?? "Tool"}")">
                                            @if (!string.IsNullOrEmpty(seg.ToolArguments))
                                            {
                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@seg.ToolArguments</pre></div>
                                            }
                                            @if (!string.IsNullOrEmpty(seg.ToolResult))
                                            {
                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@seg.ToolResult</pre></div>
                                            }
                                        </MudExpansionPanel>
                                    </MudExpansionPanels>
                                </div>
                            }
                        }
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages. Hide if already in Groups to avoid duplicate (H5). *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage) && !IsPendingMessageAlreadyInGroups())
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You ¬∑ @_pendingUserMessageTime.ToString("g")</MudText>
                <MarkdownContentView Content="@_pendingUserMessage" />
            </MudChatBubble>
        </MudChat>
    }
    @* Only show streaming block while actively streaming; after persist parent refresh shows reply from Groups (avoids duplicate AI bubble). *@
    @if (_streaming)
    {
        <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">SmallEBot ¬∑ @DateTime.Now.ToString("g")</MudText>
                @foreach (var item in GetStreamingDisplayItems())
                {
                    if (item is { IsReasoningGroup: true, ReasoningSteps: { Count: > 0 } steps })
                    {
                        var toolCount = steps.Count(x => !x.IsThink);
                        var panelTitle = toolCount > 0 ? $"üí≠ Êé®ÁêÜËøáÁ®ã (Âê´ {toolCount} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®)" : "üí≠ Êé®ÁêÜËøáÁ®ã";
                        <MudExpansionPanels Class="mt-2" Elevation="0">
                            <MudExpansionPanel expanded="false" Text="@panelTitle">
                                <div class="d-flex flex-column gap-2">
                                    @foreach (var step in steps)
                                    {
                                        if (step.IsThink)
                                        {
                                            <div class="smallebot-reasoning-step">
                                                <MudText Typo="Typo.caption" Class="mb-1 smallebot-reasoning-label">ÊÄùËÄÉ</MudText>
                                                @if (!string.IsNullOrEmpty(step.Text))
                                                {
                                                    <MarkdownContentView Content="@step.Text" CssClass="smallebot-reasoning-body" />
                                                }
                                            </div>
                                        }
                                        else if (ShowToolCalls)
                                        {
                                            <div class="smallebot-reasoning-step">
                                                <MudExpansionPanels Elevation="0" Class="pa-0">
                                                    <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                                        @if (!string.IsNullOrEmpty(step.ToolArguments))
                                                        {
                                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                                        }
                                                        @if (!string.IsNullOrEmpty(step.ToolResult))
                                                        {
                                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                                        }
                                                    </MudExpansionPanel>
                                                </MudExpansionPanels>
                                            </div>
                                        }
                                    }
                                </div>
                            </MudExpansionPanel>
                        </MudExpansionPanels>
                    }
                    else if (item.IsText)
                    {
                        <MarkdownContentView Content="@item.Text" />
                    }
                    else if (item.IsReplyTool && ShowToolCalls)
                    {
                        <div class="mt-2">
                            <MudExpansionPanels Elevation="0" Class="pa-0">
                                <MudExpansionPanel expanded="false" Text="@("üîß " + (item.ToolName ?? "Tool"))">
                                    @if (!string.IsNullOrEmpty(item.ToolArguments))
                                    {
                                        <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@item.ToolArguments</pre></div>
                                    }
                                    @if (!string.IsNullOrEmpty(item.ToolResult))
                                    {
                                        <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@item.ToolResult</pre></div>
                                    }
                                </MudExpansionPanel>
                            </MudExpansionPanels>
                        </div>
                    }
                }
                @if (!GetStreamingDisplayItems().Any() && !string.IsNullOrEmpty(_streamingText))
                {
                    <MarkdownContentView Content="@_streamingText" />
                }
            </MudChatBubble>
        </MudChat>
    }
    </div>

    <form @onsubmit="HandleSubmit" @onsubmit:preventDefault>
        <MudStack Row="true" Spacing="2" Class="mt-4">
            <MudTextField @bind-Value="_input"
                          Label="Message"
                          Variant="Variant.Outlined"
                          FullWidth="true"
                          Immediate="true" />
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       ButtonType="ButtonType.Submit"
                       Disabled="@(_streaming || string.IsNullOrWhiteSpace(_input))">
                Send
            </MudButton>
        </MudStack>
    </form>
</MudPaper>

@code {
    [Parameter] public List<MessageGroup> Groups { get; set; } = new();
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; }

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private readonly List<StreamUpdate> _streamingUpdates = [];
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>True after persist: show last streamed reply without refetching (avoids full re-render). Cleared when conversation changes or next send.</summary>
    private bool _showLastStreamedReply;

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        // Guard and capture synchronously before any await to prevent double submit (e.g. double-click or Enter+click).
        if (_streaming) return;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _streaming = true;
        _showLastStreamedReply = false;
        _streamingText = "";
        _streamingUpdates.Clear();
        _scrollToBottomRequested = true;
        StateHasChanged();

        await OnBeforeSend.InvokeAsync();

        var persisted = false;
        var turnId = Guid.Empty;
        try
        {
            var userName = await UserNameSvc.GetAsync() ?? UserName;
            if (string.IsNullOrWhiteSpace(userName))
            {
                Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
                _pendingUserMessage = "";
                _streaming = false;
                await InvokeAsync(StateHasChanged);
                return;
            }
            turnId = await AgentSvc.CreateTurnAndUserMessageAsync(ConversationId!.Value, userName, msg, UseThinkingMode);
            await foreach (var update in AgentSvc.SendMessageStreamingAsync(ConversationId!.Value, msg, UseThinkingMode))
            {
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                _scrollToBottomRequested = true;
                StateHasChanged();
            }
            var segments = BuildSegmentsForPersist();
            await AgentSvc.CompleteTurnWithAssistantAsync(ConversationId!.Value, turnId, segments);
            persisted = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
            if (turnId != default)
            {
                try
                {
                    await AgentSvc.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, ex.Message);
                    persisted = true;
                }
                catch (Exception persistEx)
                {
                    Log.LogError(persistEx, "Failed to persist error message for turn {TurnId}", turnId);
                }
            }
        }
        finally
        {
            if (persisted)
            {
                _pendingUserMessage = "";
                _streaming = false;
                _showLastStreamedReply = false;
                _scrollToBottomRequested = true;
                StateHasChanged();
                await Task.Yield();
                await OnMessageSent.InvokeAsync();
                // Parent does full refresh; one render with streaming off already done so no duplicate assistant bubble
            }
            _streaming = false;
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            _showLastStreamedReply = false;
            if (Groups.Count > 0)
                _scrollToBottomRequested = true;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollToBottomRequested || _streaming)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    /// <summary>True if the last user message in Groups has the same content as _pendingUserMessage (avoids duplicate bubble when refresh and pending overlap).</summary>
    private bool IsPendingMessageAlreadyInGroups()
    {
        if (string.IsNullOrEmpty(_pendingUserMessage) || Groups == null || Groups.Count == 0) return false;
        var lastUser = Groups.OfType<UserMessageGroup>().LastOrDefault();
        return lastUser?.Message?.Content?.Trim() == _pendingUserMessage.Trim();
    }

    /// <summary>Form submit (Enter or Send button); single entry point to avoid double send.</summary>
    private async Task HandleSubmit()
    {
        await Send();
    }

    /// <summary>Detects if the assistant group is a single error message (Content starts with "Error: ").</summary>
    private static bool IsErrorReply(IReadOnlyList<TimelineItem> items)
    {
        if (items.Count != 1) return false;
        var item = items[0];
        return item.Message is { Role: "assistant" } msg && (msg.Content?.StartsWith("Error: ", StringComparison.Ordinal) ?? false);
    }

    private IEnumerable<StreamDisplayItem> GetStreamingDisplayItems()
    {
        var reasoningSteps = new List<ReasoningStep>();
        var replyItems = new List<StreamDisplayItem>();
        var seenText = false;

        foreach (var update in _streamingUpdates)
        {
            if (update is TextStreamUpdate t)
            {
                seenText = true;
                if (replyItems.Count > 0 && replyItems[^1] is { IsText: true } lastText)
                    replyItems[^1] = new StreamDisplayItem { IsText = true, Text = (lastText.Text ?? "") + t.Text };
                else
                    replyItems.Add(new StreamDisplayItem { IsText = true, Text = t.Text });
                continue;
            }
            if (update is ThinkStreamUpdate think)
            {
                if (seenText)
                {
                    if (replyItems.Count > 0 && replyItems[^1] is { IsText: true } lt)
                        replyItems[^1] = new StreamDisplayItem { IsText = true, Text = (lt.Text ?? "") + think.Text };
                    else
                        replyItems.Add(new StreamDisplayItem { IsText = true, Text = think.Text });
                }
                else
                {
                    if (reasoningSteps.Count > 0 && reasoningSteps[^1].IsThink)
                        reasoningSteps[^1].Text = (reasoningSteps[^1].Text ?? "") + think.Text;
                    else
                        reasoningSteps.Add(new ReasoningStep { IsThink = true, Text = think.Text });
                }
                continue;
            }
            if (update is ToolCallStreamUpdate tc)
            {
                if (seenText)
                {
                    if (tc is { Result: not null, Arguments: null })
                    {
                        var lastTool = replyItems.LastOrDefault(x => x.IsReplyTool);
                        if (lastTool != null)
                            lastTool.ToolResult = tc.Result;
                    }
                    else if (!string.IsNullOrEmpty(tc.ToolName) || tc.Arguments != null)
                    {
                        replyItems.Add(new StreamDisplayItem { IsReplyTool = true, ToolName = tc.ToolName, ToolArguments = tc.Arguments, ToolResult = tc.Result });
                    }
                }
                else
                {
                    if (tc is { Result: not null, Arguments: null })
                    {
                        var lastTool = reasoningSteps.LastOrDefault(x => !x.IsThink);
                        if (lastTool != null) lastTool.ToolResult = tc.Result;
                    }
                    else if (!string.IsNullOrEmpty(tc.ToolName) || tc.Arguments != null)
                    {
                        reasoningSteps.Add(new ReasoningStep { IsThink = false, ToolName = tc.ToolName, ToolArguments = tc.Arguments, ToolResult = tc.Result });
                    }
                }
            }
        }

        var result = new List<StreamDisplayItem>();
        if (reasoningSteps.Count > 0)
        {
            result.Add(new StreamDisplayItem
            {
                IsReasoningGroup = true,
                ReasoningSteps = reasoningSteps
            });
        }
        result.AddRange(replyItems);
        return result;
    }
}
