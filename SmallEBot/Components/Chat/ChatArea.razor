@using SmallEBot.Application.Conversation
@using SmallEBot.Core.Models
@using SmallEBot.Services.Conversation
@using SmallEBot.Services.Circuit
@inject IAgentConversationService ConversationPipeline
@inject ICurrentCircuitAccessor CircuitAccessor
@inject AgentCacheService AgentCache
@inject UserNameService UserNameSvc
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject ILogger<ChatArea> Log

<MudPaper Class="pa-4 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Bubbles.Any())
    {
        @foreach (var bubble in Bubbles)
        {
            @if (bubble is UserBubble userBubble)
            {
                var msg = userBubble.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">You Â· @msg.CreatedAt.ToString("g")</MudText>
                        @if (!string.IsNullOrEmpty(msg.Content))
                        {
                            <MarkdownContentView Content="@msg.Content" />
                        }
                    </MudChatBubble>
                </MudChat>
            }
            else if (bubble is AssistantBubble asstBubble)
            {
                var blocks = ReasoningSegmenter.SegmentTurn(asstBubble.Items, asstBubble.IsThinkingMode);
                var firstCreatedAt = asstBubble.Items.Count > 0 ? asstBubble.Items[0].CreatedAt : DateTime.UtcNow;
                var isError = IsErrorReply(asstBubble.Items);
                var bubbleClass = isError ? "mb-3 smallebot-bubble smallebot-assistant-error" : "mb-3 smallebot-bubble";
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="@bubbleClass">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">SmallEBot Â· @firstCreatedAt.ToString("g")</MudText>
                        @foreach (var block in blocks)
                        {
                            @if (block.IsThinkBlock)
                            {
                                var stepViews = block.Items.Select(TimelineItemToReasoningStepView).Where(x => x != null).Cast<ReasoningStepView>().ToList();
                                var toolCount = stepViews.Count(x => !x.IsThink);
                                var panelTitle = toolCount > 0 ? $"ðŸ’­ Reasoning ({toolCount} tool calls)" : "ðŸ’­ Reasoning";
                                <MudExpansionPanels Class="mt-2" Elevation="0">
                                    <MudExpansionPanel expanded="false" Text="@panelTitle">
                                        <div class="d-flex flex-column gap-2">
                                            <ReasoningBlockView Steps="@stepViews" />
                                        </div>
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            }
                            else
                            {
                                @foreach (var item in block.Items)
                                {
                                    @if (item.Message is { } msg && !string.IsNullOrEmpty(msg.Content))
                                    {
                                        <MarkdownContentView Content="@msg.Content" />
                                    }
                                    else if (item.ThinkBlock is { } tb && !string.IsNullOrEmpty(tb.Content))
                                    {
                                        <MarkdownContentView Content="@tb.Content" />
                                    }
                                    else if (item.ToolCall is { } tc && ShowToolCalls)
                                    {
                                        <ToolCallView ToolName="@tc.ToolName" ToolArguments="@tc.Arguments" ToolResult="@tc.Result" ShowToolCalls="@ShowToolCalls" />
                                    }
                                }
                            }
                        }
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages. Hide if already in Bubbles to avoid duplicate (H5). *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage) && !IsPendingMessageAlreadyInBubbles())
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You Â· @_pendingUserMessageTime.ToString("g")</MudText>
                <MarkdownContentView Content="@_pendingUserMessage" />
            </MudChatBubble>
        </MudChat>
    }
    @* Only show streaming block while actively streaming; after persist parent refresh shows reply from Bubbles (avoids duplicate AI bubble). *@
    @if (_streaming)
    {
        <StreamingMessageView Items="@GetStreamingDisplayItemViews()"
                              FallbackText="@_streamingText"
                              Timestamp="@DateTime.Now" />
    }
    </div>

    <ChatInputBar @bind-Value="_input"
                  Streaming="_streaming"
                  ContextPercentText="@_contextPercentText"
                  ContextUsageTooltip="@_contextUsageTooltip"
                  OnSend="Send"
                  OnStop="StopSend"
                  Disabled="@string.IsNullOrWhiteSpace(_input)"
                  Class="mt-2" />
</MudPaper>

@code {
    [Parameter] public List<ChatBubble> Bubbles { get; set; } = [];
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; }

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private readonly List<StreamUpdate> _streamingUpdates = [];
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>Bubble count at start of Send(); used to detect when parent has refreshed with new turn so we clear streaming without a visible flash.</summary>
    private int _bubbleCountBeforeSend;
    private CancellationTokenSource? _sendCts;
    private string _contextPercentText = "0%";
    private string? _contextUsageTooltip;

    private void StopSend()
    {
        _sendCts?.Cancel();
    }

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        // Guard and capture synchronously before any await to prevent double submit (e.g. double-click or Enter+click).
        if (_streaming) return;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _bubbleCountBeforeSend = Bubbles.Count;
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        StateHasChanged();

        await OnBeforeSend.InvokeAsync();

        var userName = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(userName))
        {
            Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
            _pendingUserMessage = "";
            _streaming = false;
            _sendCts?.Dispose();
            _sendCts = null;
            await InvokeAsync(StateHasChanged);
            return;
        }

        var attachedPaths = AttachmentInputParser.ParseAttachedPaths(msg);
        var requestedSkillIds = AttachmentInputParser.ParseRequestedSkillIds(msg);
        var turnId = await ConversationPipeline.CreateTurnAndUserMessageAsync(ConversationId!.Value, userName, msg, UseThinkingMode, _sendCts!.Token, attachedPaths, requestedSkillIds);
        _ = RunStreamingLoopAsync(turnId, msg, attachedPaths, requestedSkillIds);
    }

    private async Task RunStreamingLoopAsync(Guid turnId, string msg, IReadOnlyList<string> attachedPaths, IReadOnlyList<string> requestedSkillIds)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var contextId = CircuitAccessor.CurrentCircuit?.Id;
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, msg, UseThinkingMode, sink, _sendCts!.Token, contextId, attachedPaths, requestedSkillIds)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try
            {
                await ConversationPipeline.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, "Stopped by user.", CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist stop message for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try
            {
                await ConversationPipeline.CompleteTurnWithErrorAsync(ConversationId!.Value, turnId, ex.Message, CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist error message for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        finally
        {
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _pendingUserMessage = "";
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _streamingUpdates.Clear();
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            if (Bubbles.Count > 0)
                _scrollToBottomRequested = true;
            _contextRefreshRequested = true;
        }
        // When parent refreshes with new turn after streaming, clear streaming state so we show only Bubbles (no duplicate, no flash).
        if (_streaming && Bubbles.Count > _bubbleCountBeforeSend)
        {
            _streaming = false;
            _streamingUpdates.Clear();
        }
    }

    private bool _contextRefreshRequested;

    protected override async Task OnParametersSetAsync()
    {
        if (_contextRefreshRequested && ConversationId.HasValue)
        {
            _contextRefreshRequested = false;
            try
            {
                var d = await AgentCache.GetEstimatedContextUsageDetailAsync(ConversationId.Value);
                if (d != null)
                {
                    _contextPercentText = $"{d.Ratio:P1}";
                    _contextUsageTooltip = $"Context: {d.Ratio:P1} Â· {AgentCacheService.FormatTokenCount(d.UsedTokens)}/{AgentCacheService.FormatTokenCount(d.ContextWindowTokens)}";
                }
                else
                {
                    _contextPercentText = "â€”";
                    _contextUsageTooltip = null;
                }
            }
            catch
            {
                _contextPercentText = "â€”";
                _contextUsageTooltip = null;
            }
        }
        else if (!ConversationId.HasValue)
        {
            _contextPercentText = "â€”";
            _contextUsageTooltip = null;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollToBottomRequested)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    /// <summary>True if the last user message in Bubbles has the same content as _pendingUserMessage (avoids duplicate bubble when refresh and pending overlap).</summary>
    private bool IsPendingMessageAlreadyInBubbles()
    {
        if (string.IsNullOrEmpty(_pendingUserMessage) || Bubbles.Count == 0) return false;
        var lastUser = Bubbles.OfType<UserBubble>().LastOrDefault();
        return lastUser?.Message.Content.Trim() == _pendingUserMessage.Trim();
    }

    /// <summary>Detects if the assistant bubble is a single error message (Content starts with "Error: ").</summary>
    private static bool IsErrorReply(IReadOnlyList<TimelineItem> items)
    {
        if (items.Count != 1) return false;
        var item = items[0];
        return item.Message is { Role: "assistant" } msg && msg.Content.StartsWith("Error: ", StringComparison.Ordinal);
    }
}
