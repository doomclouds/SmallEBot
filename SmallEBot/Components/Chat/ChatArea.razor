@using System.IO
@using SmallEBot.Application.Conversation
@using SmallEBot.Application.Streaming
@using SmallEBot.Components.Chat.ViewModels.Reasoning
@using SmallEBot.Components.Chat.ViewModels.Streaming
@using SmallEBot.Core
@using SmallEBot.Core.Models
@using SmallEBot.Models
@using SmallEBot.Services.Circuit
@inject IAgentConversationService ConversationPipeline
@inject IDialogService DialogSvc
@inject IWorkspaceUploadService UploadService
@inject ICurrentCircuitAccessor CircuitAccessor
@inject AgentCacheService AgentCache
@inject UserNameService UserNameSvc
@inject IWorkspaceService WorkspaceService
@inject ISkillsConfigService SkillsConfigService
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject ILogger<ChatArea> Log
@implements IDisposable

<MudPaper Class="pa-4 pb-1 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Bubbles.Any())
    {
        @foreach (var bubble in Bubbles)
        {
            @if (bubble is UserBubble userBubble)
            {
                var msg = userBubble.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <div class="d-flex justify-space-between align-start gap-1">
                            <div style="flex: 1">
                                <MudText Typo="Typo.caption">You Â· @msg.CreatedAt.ToString("g")@(msg.IsEdited ? " (edited)" : "")</MudText>
                                @if (msg.AttachedPaths.Count > 0 || msg.RequestedSkillIds.Count > 0)
                                {
                                    <div class="d-flex flex-wrap align-items-center gap-1 mt-1 mb-1">
                                        @foreach (var path in msg.AttachedPaths)
                                        {
                                            <MudChip T="object" Color="Color.Primary" Variant="Variant.Filled" Size="Size.Small">@path</MudChip>
                                        }
                                        @foreach (var skillId in msg.RequestedSkillIds)
                                        {
                                            <MudChip T="object" Color="Color.Secondary" Variant="Variant.Filled" Size="Size.Small">/@skillId</MudChip>
                                        }
                                    </div>
                                }
                                @if (!string.IsNullOrEmpty(msg.Content))
                                {
                                    <MarkdownContentView Content="@msg.Content" />
                                }
                            </div>
                            <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => EditUserMessage(msg))" title="Edit" />
                        </div>
                    </MudChatBubble>
                </MudChat>
            }
            else if (bubble is AssistantBubble asstBubble)
            {
                var blocks = ReasoningSegmenter.SegmentTurn(asstBubble.Items, asstBubble.IsThinkingMode);
                var firstCreatedAt = asstBubble.Items.Count > 0 ? asstBubble.Items[0].CreatedAt : DateTime.UtcNow;
                var isError = IsErrorReply(asstBubble.Items);
                var bubbleClass = isError ? "mb-3 smallebot-bubble smallebot-assistant-error" : "mb-3 smallebot-bubble";
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="@bubbleClass">
                    <MudChatBubble>
                        <div class="d-flex justify-space-between align-start gap-1">
                            <div style="flex: 1">
                                <MudText Typo="Typo.caption">SmallEBot Â· @firstCreatedAt.ToString("g")</MudText>
                        @foreach (var block in blocks)
                        {
                            @if (block.IsThinkBlock)
                            {
                                var stepViews = block.Items.Select(TimelineItemToReasoningStepView).Where(x => x != null).Cast<ReasoningStepView>().ToList();
                                var toolCount = stepViews.Count(x => !x.IsThink);
                                var panelTitle = toolCount > 0 ? $"ðŸ’­ Reasoning ({toolCount} tool calls)" : "ðŸ’­ Reasoning";
                                <MudExpansionPanels Class="mt-2" Elevation="0">
                                    <MudExpansionPanel expanded="false" Text="@panelTitle">
                                        <div class="d-flex flex-column gap-2">
                                            <ReasoningBlockView Steps="@stepViews" />
                                        </div>
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            }
                            else
                            {
                                @foreach (var item in block.Items)
                                {
                                    @if (item.Message is { } msg && !string.IsNullOrEmpty(msg.Content))
                                    {
                                        <MarkdownContentView Content="@msg.Content" />
                                    }
                                    else if (item.ThinkBlock is { } tb && !string.IsNullOrEmpty(tb.Content))
                                    {
                                        <MarkdownContentView Content="@tb.Content" />
                                    }
                                    else if (item.ToolCall is { } tc && ShowToolCalls)
                                    {
                                        <ToolCallView ToolName="@tc.ToolName" ToolArguments="@tc.Arguments" ToolResult="@tc.Result" Phase="ToolCallPhase.Completed" ShowToolCalls="@ShowToolCalls" />
                                    }
                                }
                            }
                        }
                            </div>
                            @if (asstBubble.TurnId != Guid.Empty)
                            {
                                <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" OnClick="@(() => RegenerateReply(asstBubble.TurnId))" title="Regenerate" />
                            }
                        </div>
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages. Hide if already in Bubbles to avoid duplicate (H5). *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage) && !IsPendingMessageAlreadyInBubbles())
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You Â· @_pendingUserMessageTime.ToString("g")</MudText>
                <MarkdownContentView Content="@_pendingUserMessage" />
            </MudChatBubble>
        </MudChat>
    }
    @* Only show streaming block while actively streaming; after persist parent refresh shows reply from Bubbles (avoids duplicate AI bubble). *@
    <StreamingIndicator IsStreaming="@_streaming"
                        StreamingItems="@_streamingViews"
                        FallbackText="@_streamingText"
                        Timestamp="@DateTime.Now"
                        OnCancel="StopSend"
                        ShowWaitingForToolParams="@_showWaitingForToolParams"
                        WaitingElapsed="@(_showWaitingForToolParams && _waitingForToolParamsSince.HasValue ? DateTime.UtcNow - _waitingForToolParamsSince.Value : TimeSpan.Zero)"
                        WaitingInReasoning="@_waitingInReasoning"
                        ShowToolCalls="@ShowToolCalls" />
    </div>

    <div class="mt-2">
        <ChatInputArea InputText="@_input"
                       InputTextChanged="@HandleInputChanged"
                       IsStreaming="@_streaming"
                       Attachments="@_attachmentItems"
                       RequestedSkillIds="@_requestedSkillIds"
                       PopoverOpen="@_popoverOpen"
                       PopoverKind="@_popoverKind"
                       PopoverFilter="@_popoverFilter"
                       FilePaths="@_filePaths"
                       Skills="@_skills"
                       ContextPercentText="@_contextPercentText"
                       ContextUsageTooltip="@_contextUsageTooltip"
                       OnSend="@Send"
                       OnStop="@StopSend"
                       OnRemoveAttachment="@RemoveAttachmentItem"
                       OnRemoveSkill="@RemoveRequestedSkill"
                       InputTextWithPopover="@OnAttachmentSelected" />
    </div>
</MudPaper>

@code {
    [Parameter] public List<ChatBubble> Bubbles { get; set; } = [];
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; }

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private DateTime? _streamingStartedAt;
    private string _streamingText = "";
    private readonly List<StreamUpdate> _streamingUpdates = [];
    private IReadOnlyList<StreamingDisplayItemView> _streamingViews = [];
    private DateTime? _lastStreamActivityAt;
    private bool _showWaitingForToolParams;
    private DateTime? _waitingForToolParamsSince;
    private bool _waitingInReasoning;
    private Timer? _waitingCheckTimer;
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>Bubble count at start of Send(); used to detect when parent has refreshed with new turn so we clear streaming without a visible flash.</summary>
    private int _bubbleCountBeforeSend;
    private CancellationTokenSource? _sendCts;
    private string _contextPercentText = "0%";
    private string? _contextUsageTooltip;
    private bool _popoverOpen;
    private string _popoverKind = "file";
    private string _popoverFilter = "";
    private IReadOnlyList<string> _filePaths = [];
    private IReadOnlyList<SkillMetadata> _skills = [];
    private bool _moveCursorToEnd;
    private readonly List<AttachmentItem> _attachmentItems = [];
    private readonly List<string> _requestedSkillIds = [];
    private DotNetObjectReference<ChatArea>? _dropZoneDotNetRef;
    private bool _justSelectedAttachment;

    private async Task HandleInputChanged(string v)
    {
        if (_justSelectedAttachment)
        {
            _justSelectedAttachment = false;
            return;
        }
        _input = v;
        var lastAt = v.LastIndexOf('@');
        var lastSlash = v.LastIndexOf('/');
        if (lastSlash > lastAt)
        {
            _popoverKind = "skill";
            _popoverOpen = true;
            _popoverFilter = lastSlash + 1 < v.Length ? v[(lastSlash + 1)..] : "";
            if (_skills.Count == 0)
                _skills = await SkillsConfigService.GetMetadataForAgentAsync();
        }
        else if (lastAt >= 0)
        {
            _popoverKind = "file";
            _popoverOpen = true;
            _popoverFilter = lastAt + 1 < v.Length ? v[(lastAt + 1)..] : "";
            if (_filePaths.Count == 0)
                _filePaths = await WorkspaceService.GetAllowedFilePathsAsync();
        }
        else
        {
            ClosePopover();
        }
        StateHasChanged();
    }

    private void ClosePopover()
    {
        _popoverOpen = false;
    }

    private async Task OnAttachmentSelected(string value)
    {
        if (_popoverKind == "file")
        {
            if (_attachmentItems.OfType<ResolvedPathAttachment>().All(x => x.Path != value))
                _attachmentItems.Add(new ResolvedPathAttachment(value));
            var lastAt = _input.LastIndexOf('@');
            _input = lastAt >= 0 ? _input[..lastAt].TrimEnd() : _input;
        }
        else
        {
            if (!_requestedSkillIds.Any(s => string.Equals(s, value, StringComparison.OrdinalIgnoreCase)))
                _requestedSkillIds.Add(value);
            var lastSlash = _input.LastIndexOf('/');
            _input = lastSlash >= 0 ? _input[..lastSlash].TrimEnd() : _input;
        }
        if (_input.Length > 0 && !_input.EndsWith(' '))
            _input += " ";
        _justSelectedAttachment = true;
        ClosePopover();
        _moveCursorToEnd = true;
        await InvokeAsync(StateHasChanged);
    }

    private void RemoveAttachmentItem(AttachmentItem item)
    {
        _attachmentItems.Remove(item);
        if (item is PendingUploadAttachment pending)
            UploadService.CancelUpload(pending.UploadId);
        StateHasChanged();
    }

    private void RemoveRequestedSkill(string skillId)
    {
        _requestedSkillIds.Remove(skillId);
        StateHasChanged();
    }

    private async Task EditUserMessage(SmallEBot.Core.Entities.ChatMessage msg)
    {
        if (_streaming || !ConversationId.HasValue) return;
        var parameters = new DialogParameters
        {
            [nameof(EditMessageDialog.InitialContent)] = msg.Content,
            [nameof(EditMessageDialog.InitialAttachedPaths)] = msg.AttachedPaths,
            [nameof(EditMessageDialog.InitialRequestedSkillIds)] = msg.RequestedSkillIds
        };
        var dialog = await DialogSvc.ShowAsync<EditMessageDialog>("Edit message", parameters, new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true });
        var result = await dialog.Result;
        if (result == null || result.Canceled || result.Data is not EditMessageResult editResult || string.IsNullOrWhiteSpace(editResult.Content)) return;
        _userNameForAction = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(_userNameForAction)) { Snackbar.Add("Username is missing.", Severity.Warning); return; }
        _streaming = true;
        _streamingStartedAt = DateTime.UtcNow;
        _streamingText = "";
        _streamingUpdates.Clear();
        _streamingViews = [];
        _lastStreamActivityAt = null;
        _showWaitingForToolParams = false;
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        _bubbleCountBeforeSend = Bubbles.Count;
        StartWaitingCheckTimer();
        StateHasChanged();
        await OnBeforeSend.InvokeAsync();
        _ = RunReplaceStreamingLoopAsync(msg.Id, editResult.Content.Trim(), editResult.AttachedPaths, editResult.RequestedSkillIds);
    }

    private async Task RegenerateReply(Guid turnId)
    {
        if (_streaming || !ConversationId.HasValue) return;
        _userNameForAction = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(_userNameForAction)) { Snackbar.Add("Username is missing.", Severity.Warning); return; }
        _streaming = true;
        _streamingStartedAt = DateTime.UtcNow;
        _streamingText = "";
        _streamingUpdates.Clear();
        _streamingViews = [];
        _lastStreamActivityAt = null;
        _showWaitingForToolParams = false;
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        _bubbleCountBeforeSend = Bubbles.Count;
        StartWaitingCheckTimer();
        StateHasChanged();
        await OnBeforeSend.InvokeAsync();
        _ = RunRegenerateStreamingLoopAsync(turnId);
    }

    private async Task RunReplaceStreamingLoopAsync(Guid messageId, string newContent, IReadOnlyList<string>? attachedPaths, IReadOnlyList<string>? requestedSkillIds)
    {
        var result = await ConversationPipeline.ReplaceUserMessageAsync(ConversationId!.Value, _userNameForAction!, messageId, newContent, UseThinkingMode, attachedPaths, requestedSkillIds, _sendCts!.Token);
        if (result == null) { _streaming = false; _streamingStartedAt = null; await InvokeAsync(StateHasChanged); return; }
        await OnMessageSent.InvokeAsync();
        await RunStreamingLoopForTurnAsync(result.Value.TurnId, result.Value.UserMessage, UseThinkingMode, result.Value.AttachedPaths, result.Value.RequestedSkillIds);
    }

    private async Task RunRegenerateStreamingLoopAsync(Guid turnId)
    {
        var result = await ConversationPipeline.PrepareTurnForRegenerateAsync(ConversationId!.Value, _userNameForAction!, turnId, _sendCts!.Token);
        if (result == null) { _streaming = false; _streamingStartedAt = null; await InvokeAsync(StateHasChanged); return; }
        await OnMessageSent.InvokeAsync();
        await RunStreamingLoopForTurnAsync(result.Value.TurnId, result.Value.UserMessage, result.Value.UseThinking, result.Value.AttachedPaths, result.Value.RequestedSkillIds);
    }

    private async Task RunStreamingLoopForTurnAsync(Guid turnId, string userMessage, bool useThinking, IReadOnlyList<string> attachedPaths, IReadOnlyList<string> requestedSkillIds)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, userMessage, useThinking, sink, _sendCts!.Token, CircuitAccessor.CurrentCircuit?.Id, attachedPaths, requestedSkillIds)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts!.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                _lastStreamActivityAt = DateTime.UtcNow;
                _showWaitingForToolParams = false;
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                _streamingViews = GetStreamingDisplayItemViews();
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try { await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, useThinking, "Stopped by user.", CancellationToken.None); persisted = true; } catch { /* ignore */ }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try { await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, useThinking, ex.Message, CancellationToken.None); persisted = true; } catch { /* ignore */ }
            channel.Writer.Complete();
        }
        finally
        {
            StopWaitingCheckTimer();
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _streamingStartedAt = null;
            _showWaitingForToolParams = false;
            _streamingUpdates.Clear();
            _streamingViews = [];
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private string? _userNameForAction;

    private void StopSend()
    {
        _sendCts?.Cancel();
    }

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        // Guard and capture synchronously before any await to prevent double submit (e.g. double-click or Enter+click).
        if (_streaming) return;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _bubbleCountBeforeSend = Bubbles.Count;
        _streaming = true;
        _streamingStartedAt = DateTime.UtcNow;
        _streamingText = "";
        _streamingUpdates.Clear();
        _streamingViews = [];
        _lastStreamActivityAt = null;
        _showWaitingForToolParams = false;
        _sendCts = new CancellationTokenSource();
        _scrollToBottomRequested = true;
        StartWaitingCheckTimer();
        StateHasChanged();

        await OnBeforeSend.InvokeAsync();

        var userName = await UserNameSvc.GetAsync() ?? UserName;
        if (string.IsNullOrWhiteSpace(userName))
        {
            Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
            _pendingUserMessage = "";
            _streaming = false;
            _streamingStartedAt = null;
            _sendCts?.Dispose();
            _sendCts = null;
            await InvokeAsync(StateHasChanged);
            return;
        }

        var attachedPaths = _attachmentItems.OfType<ResolvedPathAttachment>().Select(x => x.Path).ToList();
        _attachmentItems.RemoveAll(x => x is ResolvedPathAttachment);
        var requestedSkillIds = _requestedSkillIds.ToList();
        _requestedSkillIds.Clear();
        var turnId = await ConversationPipeline.CreateTurnAndUserMessageAsync(ConversationId!.Value, userName, msg, UseThinkingMode, _sendCts!.Token, attachedPaths, requestedSkillIds);
        _ = RunStreamingLoopAsync(turnId, msg, attachedPaths, requestedSkillIds);
    }

    private async Task RunStreamingLoopAsync(Guid turnId, string msg, IReadOnlyList<string> attachedPaths, IReadOnlyList<string> requestedSkillIds)
    {
        var persisted = false;
        var channel = System.Threading.Channels.Channel.CreateUnbounded<StreamUpdate>();
        var sink = new ChannelStreamSink(channel.Writer);
        var contextId = CircuitAccessor.CurrentCircuit?.Id;
        var runTask = ConversationPipeline
            .StreamResponseAndCompleteAsync(ConversationId!.Value, turnId, msg, UseThinkingMode, sink, _sendCts!.Token, contextId, attachedPaths, requestedSkillIds)
            .ContinueWith(_ => channel.Writer.Complete());

        try
        {
            await foreach (var update in channel.Reader.ReadAllAsync(_sendCts.Token))
            {
                _sendCts.Token.ThrowIfCancellationRequested();
                _lastStreamActivityAt = DateTime.UtcNow;
                _showWaitingForToolParams = false;
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                }
                _streamingViews = GetStreamingDisplayItemViews();
                await InvokeAsync(StateHasChanged);
            }
            await runTask;
            persisted = true;
        }
        catch (OperationCanceledException)
        {
            try
            {
                await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, UseThinkingMode, "Stopped by user.", CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist partial content for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        catch (Exception ex)
        {
            await InvokeAsync(() => Snackbar.Add($"Error: {ex.Message}", Severity.Error));
            try
            {
                await ConversationPipeline.CompleteTurnWithPartialContentAsync(ConversationId!.Value, turnId, _streamingUpdates, UseThinkingMode, ex.Message, CancellationToken.None);
                persisted = true;
            }
            catch (Exception persistEx)
            {
                Log.LogError(persistEx, "Failed to persist partial content for turn {TurnId}", turnId);
            }
            channel.Writer.Complete();
        }
        finally
        {
            StopWaitingCheckTimer();
            _sendCts?.Dispose();
            _sendCts = null;
            if (persisted)
            {
                _pendingUserMessage = "";
                _scrollToBottomRequested = true;
                _contextRefreshRequested = true;
                await OnMessageSent.InvokeAsync();
            }
            _streaming = false;
            _streamingStartedAt = null;
            _showWaitingForToolParams = false;
            _streamingUpdates.Clear();
            _streamingViews = [];
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void StartWaitingCheckTimer()
    {
        _waitingCheckTimer?.Dispose();
        _waitingCheckTimer = new Timer(_ => _ = InvokeAsync(RefreshWaitingState), null, 500, 500);
    }

    private void StopWaitingCheckTimer()
    {
        _waitingCheckTimer?.Dispose();
        _waitingCheckTimer = null;
    }

    private void RefreshWaitingState()
    {
        if (!_streaming) return;
        if (_lastStreamActivityAt is null) return;
        var elapsed = (DateTime.UtcNow - _lastStreamActivityAt.Value).TotalSeconds;
        if (!_showWaitingForToolParams && elapsed >= 2)
        {
            _showWaitingForToolParams = true;
            _waitingForToolParamsSince = _lastStreamActivityAt;
            _waitingInReasoning = !_streamingUpdates.Any(u => u is TextStreamUpdate);
        }
        StateHasChanged();
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            if (Bubbles.Count > 0)
                _scrollToBottomRequested = true;
            _contextRefreshRequested = true;
        }
        // When parent refreshes with new turn after streaming, clear streaming state so we show only Bubbles (no duplicate, no flash).
        if (_streaming && Bubbles.Count > _bubbleCountBeforeSend)
        {
            _streaming = false;
            _streamingStartedAt = null;
            _streamingUpdates.Clear();
            _streamingViews = [];
        }
    }

    private bool _contextRefreshRequested;

    protected override async Task OnParametersSetAsync()
    {
        if (_contextRefreshRequested && ConversationId.HasValue)
        {
            _contextRefreshRequested = false;
            try
            {
                var d = await AgentCache.GetEstimatedContextUsageDetailAsync(ConversationId.Value);
                if (d != null)
                {
                    _contextPercentText = $"{d.Ratio:P1}";
                    _contextUsageTooltip = $"Context: {d.Ratio:P1} Â· {AgentCacheService.FormatTokenCount(d.UsedTokens)}/{AgentCacheService.FormatTokenCount(d.ContextWindowTokens)}";
                }
                else
                {
                    _contextPercentText = "â€”";
                    _contextUsageTooltip = null;
                }
            }
            catch
            {
                _contextPercentText = "â€”";
                _contextUsageTooltip = null;
            }
        }
        else if (!ConversationId.HasValue)
        {
            _contextPercentText = "â€”";
            _contextUsageTooltip = null;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dropZoneDotNetRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.attachDropZone", "smallebot-chat-drop-zone", _dropZoneDotNetRef);
            }
            catch (Exception ex)
            {
                Log.LogWarning(ex, "Failed to attach drop zone");
                _dropZoneDotNetRef?.Dispose();
                _dropZoneDotNetRef = null;
            }
        }
        if (_scrollToBottomRequested)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
        if (_moveCursorToEnd)
        {
            _moveCursorToEnd = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.setChatInputValueAndCursorToEnd", "smallebot-chat-input-wrap", _input);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    [JSInvokable]
    public async Task<string?> StartUploadFromDrop(string fileName, long contentLength)
    {
        var ext = Path.GetExtension(fileName);
        if (!AllowedFileExtensions.IsAllowed(ext))
        {
            Snackbar.Add("Extension not allowed", Severity.Warning);
            return null;
        }
        var uploadId = await UploadService.StartUploadAsync(fileName, contentLength);
        _attachmentItems.Add(new PendingUploadAttachment(uploadId, fileName));
        await InvokeAsync(StateHasChanged);
        return uploadId;
    }

    [JSInvokable]
    public async Task ReportChunkAsync(string uploadId, string base64Chunk)
    {
        var chunk = Convert.FromBase64String(base64Chunk);
        await UploadService.ReportChunkAsync(uploadId, chunk);
    }

    [JSInvokable]
    public void ReportUploadProgress(string uploadId, int progress)
    {
        var pending = _attachmentItems.OfType<PendingUploadAttachment>().FirstOrDefault(p => p.UploadId == uploadId);
        if (pending != null)
        {
            pending.Progress = progress;
            _ = InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task CompleteUploadAsync(string uploadId)
    {
        var result = await UploadService.CompleteUploadAsync(uploadId);
        var idx = _attachmentItems.FindIndex(x => x is PendingUploadAttachment p && p.UploadId == uploadId);
        if (idx >= 0)
            _attachmentItems.RemoveAt(idx);
        if (result != null)
        {
            if (result.ReplacedOldPath != null)
                _attachmentItems.RemoveAll(x => x is ResolvedPathAttachment r && r.Path == result.ReplacedOldPath);
            if (_attachmentItems.OfType<ResolvedPathAttachment>().All(r => r.Path != result.Path))
                _attachmentItems.Add(new ResolvedPathAttachment(result.Path));
        }
        else
            Snackbar.Add("Upload failed", Severity.Error);
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>True if the last user message in Bubbles has the same content as _pendingUserMessage (avoids duplicate bubble when refresh and pending overlap).</summary>
    private bool IsPendingMessageAlreadyInBubbles()
    {
        if (string.IsNullOrEmpty(_pendingUserMessage) || Bubbles.Count == 0) return false;
        var lastUser = Bubbles.OfType<UserBubble>().LastOrDefault();
        return lastUser?.Message.Content.Trim() == _pendingUserMessage.Trim();
    }

    /// <summary>Detects if the assistant bubble is a single error message (Content starts with "Error: ").</summary>
    private static bool IsErrorReply(IReadOnlyList<TimelineItem> items)
    {
        if (items.Count != 1) return false;
        var item = items[0];
        return item.Message is { Role: "assistant" } msg && msg.Content.StartsWith("Error: ", StringComparison.Ordinal);
    }

    public void Dispose()
    {
        StopWaitingCheckTimer();
        try { _ = JS.InvokeVoidAsync("SmallEBot.detachDropZone", "smallebot-chat-drop-zone"); } catch { /* ignore */ }
        _dropZoneDotNetRef?.Dispose();
        _dropZoneDotNetRef = null;
    }
}
