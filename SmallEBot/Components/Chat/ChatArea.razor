@using SmallEBot.Data.Entities
@using SmallEBot.Models
@inject AgentService AgentSvc
@inject UserNameService UserNameSvc
@inject MarkdownService MarkdownSvc
@inject IJSRuntime JS
@inject ISnackbar Snackbar

<MudPaper Class="pa-4 smallebot-chat-paper" Elevation="0">
    <div @ref="_chatScrollRef" class="smallebot-chat-scroll">
    @if (Groups.Any())
    {
        @foreach (var group in Groups)
        {
            @if (group is UserMessageGroup userGroup)
            {
                var msg = userGroup.Message;
                <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">You ¬∑ @msg.CreatedAt.ToString("g")</MudText>
                        @if (!string.IsNullOrEmpty(msg.Content))
                        {
                            <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(msg.Content))</div>
                        }
                    </MudChatBubble>
                </MudChat>
            }
            else if (group is AssistantMessageGroup asstGroup)
            {
                var (reasoningSteps, textParts) = GetHistoryDisplayFromItems(asstGroup.Items);
                var firstCreatedAt = asstGroup.Items.Count > 0 ? asstGroup.Items[0].CreatedAt : DateTime.UtcNow;
                <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
                    <MudChatBubble>
                        <MudText Typo="Typo.caption">SmallEBot ¬∑ @firstCreatedAt.ToString("g")</MudText>
                        @if (reasoningSteps.Count > 0)
                        {
                            var toolCount = reasoningSteps.Count(x => !x.IsThink);
                            var panelTitle = toolCount > 0 ? $"üí≠ Êé®ÁêÜËøáÁ®ã (Âê´ {toolCount} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®)" : "üí≠ Êé®ÁêÜËøáÁ®ã";
                            <MudExpansionPanels Class="mt-2" Elevation="0">
                                <MudExpansionPanel expanded="false" Text="@panelTitle">
                                    <div class="d-flex flex-column gap-2">
                                        @foreach (var step in reasoningSteps)
                                        {
                                            if (step.IsThink)
                                            {
                                                <div class="smallebot-reasoning-step">
                                                    <MudText Typo="Typo.caption" Class="mb-1" Style="color:var(--mud-palette-primary);">ÊÄùËÄÉ</MudText>
                                                    @if (!string.IsNullOrEmpty(step.Text))
                                                    {
                                                        <div class="markdown-body" style="font-size:0.9em; color:var(--mud-palette-text-secondary);">@((MarkupString)MarkdownSvc.ToHtml(step.Text))</div>
                                                    }
                                                </div>
                                            }
                                            else if (ShowToolCalls)
                                            {
                                                <div class="smallebot-reasoning-step">
                                                    <MudExpansionPanels Elevation="0" Class="pa-0">
                                                        <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                                            @if (!string.IsNullOrEmpty(step.ToolArguments))
                                                            {
                                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                                            }
                                                            @if (!string.IsNullOrEmpty(step.ToolResult))
                                                            {
                                                                <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                                            }
                                                        </MudExpansionPanel>
                                                    </MudExpansionPanels>
                                                </div>
                                            }
                                        }
                                    </div>
                                </MudExpansionPanel>
                            </MudExpansionPanels>
                        }
                        @foreach (var text in textParts)
                        {
                            @if (!string.IsNullOrEmpty(text))
                            {
                                <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(text))</div>
                            }
                        }
                    </MudChatBubble>
                </MudChat>
            }
        }
    }
    @* Optimistic user message: show immediately when sent, until parent refreshes with persisted messages *@
    @if (!string.IsNullOrEmpty(_pendingUserMessage))
    {
        <MudChat ChatPosition="ChatBubblePosition.End" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">You ¬∑ @_pendingUserMessageTime.ToString("g")</MudText>
                <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(_pendingUserMessage))</div>
            </MudChatBubble>
        </MudChat>
    }
    @if (_streaming || _showLastStreamedReply)
    {
        <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Top" Class="mb-3 smallebot-bubble">
            <MudChatBubble>
                <MudText Typo="Typo.caption">SmallEBot ¬∑ @DateTime.Now.ToString("g")</MudText>
                @foreach (var item in GetStreamingDisplayItems())
                {
                    if (item.IsReasoningGroup && item.ReasoningSteps is { Count: > 0 } steps)
                    {
                        var toolCount = steps.Count(x => !x.IsThink);
                        var panelTitle = toolCount > 0 ? $"üí≠ Êé®ÁêÜËøáÁ®ã (Âê´ {toolCount} Ê¨°Â∑•ÂÖ∑Ë∞ÉÁî®)" : "üí≠ Êé®ÁêÜËøáÁ®ã";
                        <MudExpansionPanels Class="mt-2" Elevation="0">
                            <MudExpansionPanel expanded="false" Text="@panelTitle">
                                <div class="d-flex flex-column gap-2">
                                    @foreach (var step in steps)
                                    {
                                        if (step.IsThink)
                                        {
                                            <div class="smallebot-reasoning-step">
                                                <MudText Typo="Typo.caption" Class="mb-1" Style="color:var(--mud-palette-primary);">ÊÄùËÄÉ</MudText>
                                                @if (!string.IsNullOrEmpty(step.Text))
                                                {
                                                    <div class="markdown-body" style="font-size:0.9em; color:var(--mud-palette-text-secondary);">@((MarkupString)MarkdownSvc.ToHtml(step.Text))</div>
                                                }
                                            </div>
                                        }
                                        else if (ShowToolCalls)
                                        {
                                            <div class="smallebot-reasoning-step">
                                                <MudExpansionPanels Elevation="0" Class="pa-0">
                                                    <MudExpansionPanel expanded="false" Text="@($"üîß {step.ToolName ?? "Tool"}")">
                                                        @if (!string.IsNullOrEmpty(step.ToolArguments))
                                                        {
                                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Arguments:</MudText><pre class="d-inline">@step.ToolArguments</pre></div>
                                                        }
                                                        @if (!string.IsNullOrEmpty(step.ToolResult))
                                                        {
                                                            <div class="mt-1 d-block"><MudText Typo="Typo.caption">Result:</MudText><pre class="d-inline">@step.ToolResult</pre></div>
                                                        }
                                                    </MudExpansionPanel>
                                                </MudExpansionPanels>
                                            </div>
                                        }
                                    }
                                </div>
                            </MudExpansionPanel>
                        </MudExpansionPanels>
                    }
                    else if (item.IsText)
                    {
                        <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(item.Text))</div>
                    }
                }
                @if (!GetStreamingDisplayItems().Any() && !string.IsNullOrEmpty(_streamingText))
                {
                    <div class="markdown-body">@((MarkupString)MarkdownSvc.ToHtml(_streamingText))</div>
                }
            </MudChatBubble>
        </MudChat>
    }
    </div>

    <MudStack Row="true" Spacing="2" Class="mt-4">
        <MudTextField @bind-Value="_input"
                      Label="Message"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      OnKeyDown="@OnKeyDown" />
        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   OnClick="@Send"
                   Disabled="@(_streaming || string.IsNullOrWhiteSpace(_input))">
            Send
        </MudButton>
    </MudStack>
</MudPaper>

@code {
    [Parameter] public List<MessageGroup> Groups { get; set; } = new();
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string UserName { get; set; } = "";
    [Parameter] public EventCallback OnMessageSent { get; set; }
    [Parameter] public EventCallback OnBeforeSend { get; set; }
    [CascadingParameter(Name = "ShowToolCalls")] public bool ShowToolCalls { get; set; } = true;
    [CascadingParameter(Name = "UseThinkingMode")] public bool UseThinkingMode { get; set; } = false;

    private ElementReference _chatScrollRef;
    private string _input = "";
    private bool _streaming;
    private string _streamingText = "";
    private List<StreamUpdate> _streamingUpdates = [];
    private string _pendingUserMessage = "";
    private DateTime _pendingUserMessageTime;
    private bool _scrollToBottomRequested;
    /// <summary>True after persist: show last streamed reply without refetching (avoids full re-render). Cleared when conversation changes or next send.</summary>
    private bool _showLastStreamedReply;

    private async Task Send()
    {
        if (string.IsNullOrWhiteSpace(_input) || !ConversationId.HasValue) return;
        await OnBeforeSend.InvokeAsync();
        _showLastStreamedReply = false;
        var msg = _input.Trim();
        _input = "";
        _pendingUserMessage = msg;
        _pendingUserMessageTime = DateTime.UtcNow;
        _streaming = true;
        _streamingText = "";
        _streamingUpdates.Clear();
        _scrollToBottomRequested = true;
        StateHasChanged();

        var persisted = false;
        try
        {
            var userName = UserNameSvc.CurrentDisplayName ?? UserName;
            if (string.IsNullOrWhiteSpace(userName))
            {
                Snackbar.Add("Username is missing. Please refresh and enter your name.", Severity.Warning);
                _pendingUserMessage = "";
                _streaming = false;
                await InvokeAsync(StateHasChanged);
                return;
            }
            await foreach (var update in AgentSvc.SendMessageStreamingAsync(ConversationId!.Value, msg, UseThinkingMode))
            {
                switch (update)
                {
                    case TextStreamUpdate t:
                        _streamingText += t.Text;
                        _streamingUpdates.Add(update);
                        break;
                    case ThinkStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                    case ToolCallStreamUpdate:
                        _streamingUpdates.Add(update);
                        break;
                    default:
                        break;
                }
                _scrollToBottomRequested = true;
                StateHasChanged();
            }
            var items = GetStreamingDisplayItems().ToList();
            var segments = new List<AssistantSegment>();
            foreach (var x in items)
            {
                if (x.IsReasoningGroup && x.ReasoningSteps != null)
                {
                    foreach (var step in x.ReasoningSteps)
                    {
                        if (step.IsThink)
                            segments.Add(new AssistantSegment(IsText: false, IsThink: true, Text: step.Text ?? ""));
                        else
                            segments.Add(new AssistantSegment(IsText: false, IsThink: false, ToolName: step.ToolName ?? "", Arguments: step.ToolArguments, Result: step.ToolResult));
                    }
                }
                else if (x.IsText)
                {
                    segments.Add(new AssistantSegment(IsText: true, Text: x.Text ?? ""));
                }
            }
            if (segments.Count == 0 && !string.IsNullOrEmpty(_streamingText))
                segments.Add(new AssistantSegment(IsText: true, Text: _streamingText));
            await AgentSvc.PersistMessagesAsync(ConversationId!.Value, userName, msg, segments);
            persisted = true;
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
        finally
        {
            if (persisted)
            {
                await OnMessageSent.InvokeAsync();
                _pendingUserMessage = "";
                // Parent does full refresh; do not show streaming block to avoid duplicate reply
            }
            _streaming = false;
            _scrollToBottomRequested = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    protected override void OnParametersSet()
    {
        if (ConversationId.HasValue && ConversationId != _lastConversationId)
        {
            _lastConversationId = ConversationId;
            _showLastStreamedReply = false;
            if (Groups.Count > 0)
                _scrollToBottomRequested = true;
        }
    }

    private Guid? _lastConversationId;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_scrollToBottomRequested || _streaming)
        {
            _scrollToBottomRequested = false;
            try
            {
                await JS.InvokeVoidAsync("SmallEBot.scrollChatToBottom", _chatScrollRef);
            }
            catch { /* ignore if JS not loaded or disconnected */ }
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e is { Key: "Enter", ShiftKey: false }) await Send();
    }

    private static (List<ReasoningStep>, List<string>) GetHistoryDisplayFromItems(IReadOnlyList<TimelineItem> items)
    {
        var reasoningSteps = new List<ReasoningStep>();
        var textParts = new List<string>();
        var seenText = false;
        foreach (var item in items)
        {
            if (item.Message != null && item.Message.Role == "assistant")
            {
                seenText = true;
                if (!string.IsNullOrEmpty(item.Message.Content))
                    textParts.Add(item.Message.Content);
            }
            else if (!seenText)
            {
                if (item.ThinkBlock != null)
                    reasoningSteps.Add(new ReasoningStep { IsThink = true, Text = item.ThinkBlock.Content });
                else if (item.ToolCall != null)
                    reasoningSteps.Add(new ReasoningStep { IsThink = false, ToolName = item.ToolCall.ToolName, ToolArguments = item.ToolCall.Arguments, ToolResult = item.ToolCall.Result });
            }
        }
        return (reasoningSteps, textParts);
    }

    private sealed class ReasoningStep
    {
        public bool IsThink { get; init; }
        public string? Text { get; set; }
        public string? ToolName { get; init; }
        public string? ToolArguments { get; init; }
        public string? ToolResult { get; set; }
    }

    private sealed class StreamDisplayItem
    {
        public bool IsReasoningGroup { get; init; }
        public List<ReasoningStep>? ReasoningSteps { get; init; }
        public bool IsText { get; init; }
        public bool IsThink { get; init; }
        public string? Text { get; init; }
        public string? ToolName { get; init; }
        public string? ToolArguments { get; init; }
        public string? ToolResult { get; set; }
    }

    private IEnumerable<StreamDisplayItem> GetStreamingDisplayItems()
    {
        var rawList = new List<StreamDisplayItem>();
        var reasoningSteps = new List<ReasoningStep>();
        var seenText = false;

        foreach (var update in _streamingUpdates)
        {
            if (update is TextStreamUpdate t)
            {
                seenText = true;
                if (rawList.Count > 0 && rawList[^1] is { IsText: true } lastText)
                    rawList[rawList.Count - 1] = new StreamDisplayItem { IsText = true, Text = (lastText.Text ?? "") + t.Text };
                else
                    rawList.Add(new StreamDisplayItem { IsText = true, Text = t.Text });
                continue;
            }
            if (update is ThinkStreamUpdate think)
            {
                if (seenText)
                {
                    if (rawList.Count > 0 && rawList[^1] is { IsText: true } lt)
                        rawList[rawList.Count - 1] = new StreamDisplayItem { IsText = true, Text = (lt.Text ?? "") + think.Text };
                    else
                        rawList.Add(new StreamDisplayItem { IsText = true, Text = think.Text });
                }
                else
                {
                    if (reasoningSteps.Count > 0 && reasoningSteps[^1].IsThink)
                        reasoningSteps[^1].Text = (reasoningSteps[^1].Text ?? "") + think.Text;
                    else
                        reasoningSteps.Add(new ReasoningStep { IsThink = true, Text = think.Text });
                }
                continue;
            }
            if (update is ToolCallStreamUpdate tc)
            {
                if (seenText) continue;
                if (tc.Result != null && tc.Arguments == null)
                {
                    var lastTool = reasoningSteps.LastOrDefault(x => !x.IsThink);
                    if (lastTool != null)
                        lastTool.ToolResult = tc.Result;
                }
                else if (!string.IsNullOrEmpty(tc.ToolName) || tc.Arguments != null)
                {
                    reasoningSteps.Add(new ReasoningStep { IsThink = false, ToolName = tc.ToolName, ToolArguments = tc.Arguments, ToolResult = tc.Result });
                }
            }
        }

        var result = new List<StreamDisplayItem>();
        if (reasoningSteps.Count > 0)
        {
            var toolCount = reasoningSteps.Count(x => !x.IsThink);
            result.Add(new StreamDisplayItem
            {
                IsReasoningGroup = true,
                ReasoningSteps = reasoningSteps
            });
        }
        result.AddRange(rawList.Where(x => x.IsText));
        return result;
    }
}
